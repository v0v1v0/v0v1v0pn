<div class="container">

<table style="width: 100%;"><tr>
<td>mlePP-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class <code>"mlePP"</code> for results of maximum likelihood estimation of Poisson processes with covariates</h2>

<h3>Description</h3>

<p>This class encapsulates  the output from the  maximum likelihood  estimation of  a Poisson process where the 
intensity is modeled as a linear function of  covariates.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form  <code>new("mlePP", ...)</code>, but most often as the 
result of a call to <code>fitPP.fun</code>.  </p>


<h3>Slots</h3>


<dl>
<dt>
<code>call</code>:</dt>
<dd>
<p>Object of class <code>"language"</code>.  The call to <code>fitPP.fun</code>.</p>
</dd>
<dt>
<code>coef</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>. The estimated coefficientes of the model. </p>
</dd>
<dt>
<code>fullcoef</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>. The  full coefficient vector, including the fixed 
parameters of the model. It has an attribute, called 'TypeCoeff' which shows  the names of the fixed parameters.</p>
</dd>
<dt>
<code>vcov</code>:</dt>
<dd>
<p>Object of class <code>"matrix"</code>. Approximate variance-covariance matrix of the estimated coefficients.
It has an attribute, called 'CalMethod' which shows the method  used to calcualte the  inverse of the information matrix: 
'Solve function', 'Cholesky', 'Not possible' or 'Not required' if  <code>modCI=FALSE</code>.</p>
</dd>
<dt>
<code>min</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>. Minimum value of objective function, that is the 
negative of the loglikelihood function. </p>
</dd>
<dt>
<code>details</code>:</dt>
<dd>
<p>Object of class <code>"list"</code>. The output returned from <code>optim</code>. 
If  <code>nlminb</code> is used to minimize the function, it is NULL.</p>
</dd>
<dt>
<code>minuslogl</code>:</dt>
<dd>
<p>Object of class <code>"function"</code>.  The negative  of the loglikelihood function.</p>
</dd>
<dt>
<code>nobs</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code>.  The number of observations.</p>
</dd>
<dt>
<code>method</code>:</dt>
<dd>
<p>Object of class <code>"character"</code>.  It is a bit different from the slot in  the extended 
class 	<code>mle</code>: here,
it is the input argument <code>minfun</code> of <code>fitPP.fun</code> instead of the  method used 
in <code>optim</code> (this information already appears in <code>details</code>).</p>
</dd>
<dt>
<code>detailsb</code>:</dt>
<dd>
<p>Object of class <code>"list"</code>.The output returned from <code>nlminb</code>. 
If  <code>optim</code> is used to minimize the function, it is NULL.</p>
</dd>
<dt>
<code>npar</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code>. Number of estimated parameters.</p>
</dd>
<dt>
<code>inddat</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>.  Input argument  of <code>fitPP.fun</code>.</p>
</dd>
<dt>
<code>lambdafit</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>. Vector of the fitted intensity <code class="reqn">\hat \lambda(t)</code>.</p>
</dd>
<dt>
<code>LIlambda</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>. Vector of lower limits of the CI.</p>
</dd>
<dt>
<code>UIlambda</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>. Vector of upper limits of the CI.</p>
</dd>
<dt>
<code>convergence</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code>. A code of convergence. 0 indicates successful convergence. </p>
</dd>
<dt>
<code>posE</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>. Input argument  of <code>fitPP.fun</code>.</p>
</dd>
<dt>
<code>covariates</code>:</dt>
<dd>
<p>Object of class <code>"matrix"</code>. Input argument  of <code>fitPP.fun</code>.</p>
</dd> 
<dt>
<code>tit</code>:</dt>
<dd>
<p>Object of class <code>"character"</code>. Input argument of <code>fitPP.fun</code>.</p>
</dd> 
<dt>
<code>tind</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code>. Input argument of <code>fitPP.fun</code>.</p>
</dd>
<dt>
<code>t</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>. Input argument of <code>fitPP.fun</code>.</p>
</dd> 
</dl>
<h3>Extends</h3>

<p>Class <code>"mle"</code>, directly.</p>


<h3>Methods</h3>

<p>Most of the  S4 methods in <span class="pkg">stats4</span>  for the S4-class <code>mle</code> can be used.  Also  a  <code>mle</code> method 
for  the generic function <code>extractAIC</code> and a version of the <code>profile</code>  
<code>mle</code>  method adapted to the  <code>mlePP</code> objects are available:
</p>

<dl>
<dt>coef</dt>
<dd>
<p><code>signature(object = "mle")</code></p>
</dd>
<dt>logLik</dt>
<dd>
<p><code>signature(object = "mle")</code></p>
</dd>
<dt>nobs</dt>
<dd>
<p><code>signature(object = "mle")</code></p>
</dd>
<dt>show</dt>
<dd>
<p><code>signature(object = "mle")</code></p>
</dd>
<dt>summary</dt>
<dd>
<p><code>signature(object = "mle")</code></p>
</dd>
<dt>update</dt>
<dd>
<p><code>signature(object = "mle")</code></p>
</dd>
<dt>vcov</dt>
<dd>
<p><code>signature(object = "mle")</code></p>
</dd>
<dt>confint</dt>
<dd>
<p><code>signature(object = "mle")</code></p>
</dd>
<dt>extractAIC</dt>
<dd>
<p><code>signature(object = "mle")</code></p>
</dd>
<dt>profile</dt>
<dd>
<p><code>signature(fitted = "mlePP")</code></p>
</dd>
</dl>
<p>Some other generic functions related to fitted models, such as <code>AIC</code> or <code>BIC</code>, can  also  
be applied to <code>mlePP</code> objects. 
</p>


<h3>Note</h3>

<p>Let us remind that, as in all the S4-classes,  the symbol @  must be used instead of $ to name the slots: mlePP@covariates, 
mlepp@lambdafit, etc.</p>


<h3>See Also</h3>

<p><code>fitPP.fun</code>,  <code>mle</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">showClass("mlePP")
</code></pre>


</div>