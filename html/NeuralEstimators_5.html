<div class="container">

<table style="width: 100%;"><tr>
<td>encodedata</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>encodedata</h2>

<h3>Description</h3>

<p>for data <code>Z</code> with missing (<code>NA</code>) entries, returns an augmented data set (U, W) where W encodes the missingness pattern as an indicator vector and U is the original data Z with missing entries replaced by a fixed constant <code>c</code>.
</p>
<p>The indicator vector W is stored in the second-to-last dimension of <code>Z</code>, which should be singleton. If the second-to-last dimension is not singleton, then two singleton dimensions will be added to the array, and W will be stored in the new second-to-last dimension.
</p>


<h3>Usage</h3>

<pre><code class="language-R">encodedata(Z, c = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>data containing <code>NA</code> entries</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>fixed constant with which to replace <code>NA</code> entries</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Augmented data set (U, W). If <code>Z</code> is provided as a list, the return type will be a <code>JuliaProxy</code> object; these objects can be indexed in the usual manner (e.g., using <code>[[</code>), or converted to an R object using <code>juliaGet()</code> (note however that <code>juliaGet()</code> can be slow for large data sets).
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library("NeuralEstimators")
Z &lt;- matrix(c(1, 2, NA, NA, 5, 6, 7, NA, 9), nrow = 3)
encodedata(Z)
encodedata(list(Z, Z))
## End(Not run)
</code></pre>


</div>