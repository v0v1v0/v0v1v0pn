<div class="container">

<table style="width: 100%;"><tr>
<td>na_type</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create type objects</h2>

<h3>Description</h3>

<p>In nanoarrow, types, fields, and schemas are all represented by a
nanoarrow_schema. These functions are convenience
constructors to create these objects in a readable way. Use <code>na_type()</code> to
construct types based on the constructor name, which is also the name that
prints/is returned by <code>nanoarrow_schema_parse()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">na_type(
  type_name,
  byte_width = NULL,
  unit = NULL,
  timezone = NULL,
  column_types = NULL,
  item_type = NULL,
  key_type = NULL,
  value_type = NULL,
  index_type = NULL,
  ordered = NULL,
  list_size = NULL,
  keys_sorted = NULL,
  storage_type = NULL,
  extension_name = NULL,
  extension_metadata = NULL,
  nullable = NULL
)

na_na(nullable = TRUE)

na_bool(nullable = TRUE)

na_int8(nullable = TRUE)

na_uint8(nullable = TRUE)

na_int16(nullable = TRUE)

na_uint16(nullable = TRUE)

na_int32(nullable = TRUE)

na_uint32(nullable = TRUE)

na_int64(nullable = TRUE)

na_uint64(nullable = TRUE)

na_half_float(nullable = TRUE)

na_float(nullable = TRUE)

na_double(nullable = TRUE)

na_string(nullable = TRUE)

na_large_string(nullable = TRUE)

na_string_view(nullable = TRUE)

na_binary(nullable = TRUE)

na_large_binary(nullable = TRUE)

na_fixed_size_binary(byte_width, nullable = TRUE)

na_binary_view(nullable = TRUE)

na_date32(nullable = TRUE)

na_date64(nullable = TRUE)

na_time32(unit = c("ms", "s"), nullable = TRUE)

na_time64(unit = c("us", "ns"), nullable = TRUE)

na_duration(unit = c("ms", "s", "us", "ns"), nullable = TRUE)

na_interval_months(nullable = TRUE)

na_interval_day_time(nullable = TRUE)

na_interval_month_day_nano(nullable = TRUE)

na_timestamp(unit = c("us", "ns", "s", "ms"), timezone = "", nullable = TRUE)

na_decimal128(precision, scale, nullable = TRUE)

na_decimal256(precision, scale, nullable = TRUE)

na_struct(column_types = list(), nullable = FALSE)

na_sparse_union(column_types = list())

na_dense_union(column_types = list())

na_list(item_type, nullable = TRUE)

na_large_list(item_type, nullable = TRUE)

na_fixed_size_list(item_type, list_size, nullable = TRUE)

na_map(key_type, item_type, keys_sorted = FALSE, nullable = TRUE)

na_dictionary(value_type, index_type = na_int32(), ordered = FALSE)

na_extension(storage_type, extension_name, extension_metadata = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>type_name</code></td>
<td>
<p>The name of the type (e.g., "int32"). This form of the
constructor is useful for writing tests that loop over many types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>byte_width</code></td>
<td>
<p>For <code>na_fixed_size_binary()</code>, the number of bytes
occupied by each item.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit</code></td>
<td>
<p>One of 's' (seconds), 'ms' (milliseconds), 'us' (microseconds),
or 'ns' (nanoseconds).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timezone</code></td>
<td>
<p>A string representing a timezone name. The empty string ""
represents a naive point in time (i.e., one that has no associated
timezone).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>column_types</code></td>
<td>
<p>A <code>list()</code> of nanoarrow_schemas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item_type</code></td>
<td>
<p>For <code>na_list()</code>, <code>na_large_list()</code>, <code>na_fixed_size_list()</code>,
and <code>na_map()</code>, the nanoarrow_schema representing
the item type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key_type</code></td>
<td>
<p>The nanoarrow_schema representing the
<code>na_map()</code> key type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value_type</code></td>
<td>
<p>The nanoarrow_schema representing the
<code>na_dictionary()</code> or <code>na_map()</code> value type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index_type</code></td>
<td>
<p>The nanoarrow_schema representing the
<code>na_dictionary()</code> index type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>Use <code>TRUE</code> to assert that the order of values in the
dictionary are meaningful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list_size</code></td>
<td>
<p>The number of elements in each item in a
<code>na_fixed_size_list()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keys_sorted</code></td>
<td>
<p>Use <code>TRUE</code> to assert that keys are sorted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>storage_type</code></td>
<td>
<p>For <code>na_extension()</code>, the underlying value type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extension_name</code></td>
<td>
<p>For <code>na_extension()</code>, the extension name. This is
typically namespaced separated by dots (e.g., arrow.r.vctrs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extension_metadata</code></td>
<td>
<p>A string or raw vector defining extension metadata.
Most Arrow extension types define extension metadata as a JSON object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullable</code></td>
<td>
<p>Use <code>FALSE</code> to assert that this field cannot contain
null values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision</code></td>
<td>
<p>The total number of digits representable by the decimal type</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>The number of digits after the decimal point in a decimal type</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A nanoarrow_schema
</p>


<h3>Examples</h3>

<pre><code class="language-R">na_int32()
na_struct(list(col1 = na_int32()))

</code></pre>


</div>