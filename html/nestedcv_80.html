<div class="container">

<table style="width: 100%;"><tr>
<td>repeatcv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Repeated nested CV</h2>

<h3>Description</h3>

<p>Performs repeated calls to a <code>nestedcv</code> model to determine performance across
repeated runs of nested CV.
</p>


<h3>Usage</h3>

<pre><code class="language-R">repeatcv(
  expr,
  n = 5,
  repeat_folds = NULL,
  keep = TRUE,
  extra = FALSE,
  progress = TRUE,
  rep.cores = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>An expression containing a call to <code>nestcv.glmnet()</code>,
<code>nestcv.train()</code>, <code>nestcv.SuperLearner()</code> or <code>outercv()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of repeats</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeat_folds</code></td>
<td>
<p>Optional list containing fold indices to be applied to
the outer CV folds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>Logical whether to save repeated outer CV predictions for ROC
curves etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra</code></td>
<td>
<p>Logical whether additional performance metrics are gathered for
binary classification models. See <code>metrics()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>Logical whether to show progress.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rep.cores</code></td>
<td>
<p>Integer specifying number of cores/threads to invoke.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We recommend using this with the R pipe <code style="white-space: pre;">⁠|&gt;⁠</code> (see examples).
</p>
<p>When comparing models, it is recommended to fix the sets of outer CV folds
used across each repeat for comparing performance between models. The
function <code>repeatfolds()</code> can be used to create a fixed set of outer CV folds
for each repeat.
</p>
<p>Parallelisation over repeats is performed using <code>parallel::mclapply</code> (not
available on windows). Beware that <code>cv.cores</code> can still be set within calls
to <code>nestedcv</code> models (= nested parallelisation). This means that <code>rep.cores</code>
x <code>cv.cores</code> number of processes/forks will be spawned, so be careful not to
overload your CPU. In general parallelisation of repeats using <code>rep.cores</code> is
faster than parallelisation using <code>cv.cores</code>.
</p>


<h3>Value</h3>

<p>List of S3 class 'repeatcv' containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the model call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result</code></td>
<td>
<p>matrix of performance metrics</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>(if <code>keep = TRUE</code>) a matrix or dataframe containing the outer CV
predictions from each repeat</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roc</code></td>
<td>
<p>(binary classification models only) a ROC curve object based on
predictions across all repeats as returned in <code>output</code>, generated by
<code>pROC::roc()</code></p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">
data("iris")
dat &lt;- iris
y &lt;- dat$Species
x &lt;- dat[, 1:4]

res &lt;- nestcv.glmnet(y, x, family = "multinomial", alphaSet = 1,
                     n_outer_folds = 4) |&gt;
       repeatcv(3, rep.cores = 2)
res
summary(res)

## set up fixed fold indices
set.seed(123, "L'Ecuyer-CMRG")
folds &lt;- repeatfolds(y, repeats = 3, n_outer_folds = 4)
res &lt;- nestcv.glmnet(y, x, family = "multinomial", alphaSet = 1,
                     n_outer_folds = 4) |&gt;
       repeatcv(3, repeat_folds = folds, rep.cores = 2)
res

</code></pre>


</div>