<div class="container">

<table style="width: 100%;"><tr>
<td>core_periphery</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Discrete core-periphery model</h2>

<h3>Description</h3>

<p>Fits a discrete core-periphery model to a given network
</p>


<h3>Usage</h3>

<pre><code class="language-R">core_periphery(graph, method = "rk1_dc", iter = 500, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>igraph object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>algorithm to use (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of iterations if <code>method=GA</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other parameters for GA</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function fits the data to an optimal pattern matrix with a genetic algorithm (method="GA") or a rank 1 approximation, either with degree centrality (method="rk1_dc") or eigenvector centrality (method="rk1_ec") . The rank 1 approximation is computationally far cheaper but also more experimental. Best is to compare the results from both models.
</p>


<h3>Value</h3>

<p>list with numeric vector with entries (k1,k2,...ki...) where ki assigns vertex i to either the core (ki=1) or periphery (ki=0), and the maximal correlation with an optimal pattern matrix
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Borgatti, Stephen P., and Martin G. Everett. "Models of core/periphery structures." Social networks 21.4 (2000): 375-395.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(121)
# split graphs have a perfect core-periphery structure
sg &lt;- split_graph(n = 20, p = 0.3, core = 0.5)
core_periphery(sg)
</code></pre>


</div>