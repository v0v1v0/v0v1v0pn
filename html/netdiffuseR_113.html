<div class="container">

<table style="width: 100%;"><tr>
<td>diffnet-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Creates a <code>diffnet</code> class object</h2>

<h3>Description</h3>

<p><code>diffnet</code> objects contain difussion networks. With adjacency
matrices and time of adoption (toa) vector as its main components, most of the
package's functions have methods for this class of objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">as_diffnet(graph, ...)

## Default S3 method:
as_diffnet(graph, ...)

## S3 method for class 'networkDynamic'
as_diffnet(graph, toavar, ...)

new_diffnet(
  graph,
  toa,
  t0 = min(toa, na.rm = TRUE),
  t1 = max(toa, na.rm = TRUE),
  vertex.dyn.attrs = NULL,
  vertex.static.attrs = NULL,
  id.and.per.vars = NULL,
  graph.attrs = NULL,
  undirected = getOption("diffnet.undirected"),
  self = getOption("diffnet.self"),
  multiple = getOption("diffnet.multiple"),
  name = "Diffusion Network",
  behavior = "Unspecified"
)

## S3 method for class 'diffnet'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  attr.class = c("dyn", "static"),
  ...
)

diffnet.attrs(
  graph,
  element = c("vertex", "graph"),
  attr.class = c("dyn", "static"),
  as.df = FALSE
)

diffnet.attrs(graph, element = "vertex", attr.class = "static") &lt;- value

diffnet.toa(graph)

diffnet.toa(graph, i) &lt;- value

## S3 method for class 'diffnet'
print(x, ...)

nodes(graph)

diffnetLapply(graph, FUN, ...)

## S3 method for class 'diffnet'
str(object, ...)

## S3 method for class 'diffnet'
dimnames(x)

## S3 method for class 'diffnet'
t(x)

## S3 method for class 'diffnet'
dim(x)

is_undirected(x)

## S3 method for class 'diffnet'
is_undirected(x)

## Default S3 method:
is_undirected(x)

is_self(x)

## S3 method for class 'diffnet'
is_self(x)

## Default S3 method:
is_self(x)

is_multiple(x)

## S3 method for class 'diffnet'
is_multiple(x)

## Default S3 method:
is_multiple(x)

is_valued(x)

## S3 method for class 'diffnet'
is_valued(x)

## Default S3 method:
is_valued(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>A dynamic graph (see <code>netdiffuseR-graphs</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to the jmethod.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toavar</code></td>
<td>
<p>Character scalar. Name of the variable that holds the time of adoption.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toa</code></td>
<td>
<p>Numeric vector of size <code class="reqn">n</code>. Times of adoption.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t0</code></td>
<td>
<p>Integer scalar. Passed to <code>toa_mat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t1</code></td>
<td>
<p>Integer scalar. Passed to <code>toa_mat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertex.dyn.attrs</code></td>
<td>
<p>Vertices dynamic attributes (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertex.static.attrs</code></td>
<td>
<p>Vertices static attributes (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id.and.per.vars</code></td>
<td>
<p>A character vector of length 2. Optionally specified to check the
order of the rows in the attribute data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph.attrs</code></td>
<td>
<p>Graph dynamic attributes (not supported yet).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>undirected</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> only the lower triangle of the adjacency matrix will considered (faster).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> allows multiple edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>Character scalar. Name of the diffusion network (descriptive).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>behavior</code></td>
<td>
<p>Character scalar. Name of the behavior been analyzed (innovation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>diffnet</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optional</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr.class</code></td>
<td>
<p>Character vector/scalar. Indicates the class of the attribute, either dynamic (<code>"dyn"</code>),
or static (<code>"static"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>element</code></td>
<td>
<p>Character vector/scalar. Indicates what to retrieve/alter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.df</code></td>
<td>
<p>Logical scalar. When TRUE returns a data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>In the case of <code>diffnet.toa</code>, replacement, otherwise see below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>Indices specifying elements to replace. See <code>Extract</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>a function to be passed to lapply</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>diffnet</code> object.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>diffnet</code> objects hold both, static and dynamic vertex attributes. When
creating <code>diffnet</code> objects, these can be specified using the arguments
<code>vertex.static.attrs</code> and <code>vertex.dyn.attrs</code>; depending on whether
the attributes to specify are static or dynamic, <span class="pkg">netdiffuseR</span> currently
supports the following objects:
</p>

<table>
<tr>
<td style="text-align: left;">
<strong>Class</strong>    </td>
<td style="text-align: left;"> <strong>Dimension</strong>               </td>
<td style="text-align: right;"> <strong>Check sorting</strong>
</td>
</tr>
<tr>
<td style="text-align: left;">
<em>Static attributes</em> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>matrix</code>     </td>
<td style="text-align: left;"> with <code class="reqn">n</code> rows                </td>
<td style="text-align: right;"> <code>id</code> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>data.frame</code> </td>
<td style="text-align: left;"> with <code class="reqn">n</code> rows                </td>
<td style="text-align: right;"> <code>id</code> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>vector</code>     </td>
<td style="text-align: left;"> of length <code class="reqn">n</code>                </td>
<td style="text-align: right;"> - </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<em>Dynamic attributes</em> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>matrix</code>     </td>
<td style="text-align: left;"> with <code class="reqn">n\times T</code> rows </td>
<td style="text-align: right;"> <code>id</code>, <code>per</code> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>data.frame</code> </td>
<td style="text-align: left;"> with <code class="reqn">n\times T</code> rows </td>
<td style="text-align: right;"> <code>id</code>, <code>per</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vector</code>     </td>
<td style="text-align: left;"> of length <code class="reqn">n\times T</code>   </td>
<td style="text-align: right;"> - </td>
</tr>
<tr>
<td style="text-align: left;">
<code>list</code>       </td>
<td style="text-align: left;"> of length <code class="reqn">T</code> with matrices or data.frames of <code class="reqn">n</code> rows</td>
<td style="text-align: right;"> <code>id</code>, <code>per</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>The last column, <strong>Check sorting</strong>, lists the variables that
the user should specify if he wants the function to check the order of the rows
of the attributes (notice that this is not possible for the case of vectors).
By providing the name of the vertex id variable, <code>id</code>, and the time period
id variable, <code>per</code>, the function makes sure that the attribute data is
presented in the right order. See the example below. If the user does not
provide the names of the vertex id and time period variables then the function
does not check the way the rows are sorted, further it assumes that the data
is in the correct order.
</p>
<p>The function 'is_undirected' returns TRUE if the network is marked
as undirected. In the case of 'diffnet' objects, this information is stored
in the 'meta' element as 'undirected'. The default method is to try to find
an attribute called 'undirected', i.e., 'attr(x, "undirected")', if no
attribute is found, then the function returns 'FALSE'.
</p>
<p>The functions 'is_self', 'is_valued', and 'is_multiple' work exactly the same
as 'is_undirected'. 'diffnet' networks are not valued.
</p>


<h3>Value</h3>

<p>A list of class <code>diffnet</code> with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>A list of length <code class="reqn">T</code>. Containing sparse square matrices of size <code class="reqn">n</code>
and class <code>dgCMatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toa</code></td>
<td>
<p>An integer vector of size <code class="reqn">T</code> with times of adoption.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adopt, cumadopt</code></td>
<td>
<p>Numeric matrices of size <code class="reqn">n\times T</code> as those returned
by <code>toa_mat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertex.static.attrs</code></td>
<td>
<p>If not NULL, a data frame with <code class="reqn">n</code> rows with vertex static
attributes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertex.dyn.attrs</code></td>
<td>
<p>A list of length <code class="reqn">T</code> with data frames containing vertex attributes
throught time (dynamic).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph.attrs</code></td>
<td>
<p>A data frame with <code class="reqn">T</code> rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meta</code></td>
<td>
<p>A list of length 9 with the following elements:
</p>

<ul>
<li> <p><code>type</code>: Character scalar equal to <code>"dynamic"</code>.
</p>
</li>
<li> <p><code>class</code>: Character scalar equal to <code>"list"</code>.
</p>
</li>
<li> <p><code>ids</code>: Character vector of size <code class="reqn">n</code> with vertices' labels.
</p>
</li>
<li> <p><code>pers</code>: Integer vector of size <code class="reqn">T</code>.
</p>
</li>
<li> <p><code>nper</code>: Integer scalar equal to <code class="reqn">T</code>.
</p>
</li>
<li> <p><code>n</code>: Integer scalar equal to <code class="reqn">n</code>.
</p>
</li>
<li> <p><code>self</code>: Logical scalar.
</p>
</li>
<li> <p><code>undirected</code>: Logical scalar.
</p>
</li>
<li> <p><code>multiple</code>: Logical scalar.
</p>
</li>
<li> <p><code>name</code>: Character scalar.
</p>
</li>
<li> <p><code>behavior</code>: Character scalar.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Auxiliary functions</h3>

<p><code>diffnet.attrs</code> Allows retriving network attributes. In particular, by default
returns a list of length <code class="reqn">T</code> with data frames with the following columns:
</p>

<ol>
<li> <p><code>per</code> Indicating the time period to which the observation corresponds.
</p>
</li>
<li> <p><code>toa</code> Indicating the time of adoption of the vertex.
</p>
</li>
<li>
<p> Further columns depending on the vertex and graph attributes.
</p>
</li>
</ol>
<p>Each vertex static attributes' are repeated <code class="reqn">T</code> times in total so that these
can be binded (<code>rbind</code>) to dynamic attributes.
</p>
<p>When <code>as.df=TRUE</code>, this convenience function is useful as it can be used
to create event history (panel data) datasets used for model fitting.
</p>
<p>Conversely, the replacement method allows including new vertex or graph
attributes either dynamic or static (see examples below).
</p>
<p><code>diffnet.toa(graph)</code> works as an alias of <code>graph$toa</code>.
The replacement method, <code>diffnet.toa&lt;-</code> used as <code>diffnet.toa(graph)&lt;-...</code>,
is the right way of modifying times of adoption as when doing so it
performs several checks on the time ranges, and
recalculates adoption and cumulative adoption matrices using <code>toa_mat</code>.
</p>
<p><code>nodes(graph)</code> is an alias for <code>graph$meta$ids</code>.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Default options are listed at <code>netdiffuseR-options</code>
</p>
<p>Other diffnet methods: 
<code>%*%()</code>,
<code>as.array.diffnet()</code>,
<code>c.diffnet()</code>,
<code>diffnet-arithmetic</code>,
<code>diffnet_index</code>,
<code>plot.diffnet()</code>,
<code>summary.diffnet()</code>
</p>
<p>Other data management functions: 
<code>edgelist_to_adjmat()</code>,
<code>egonet_attrs()</code>,
<code>isolated()</code>,
<code>survey_to_diffnet()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Creating a random graph
set.seed(123)
graph &lt;- rgraph_ba(t=9)
graph &lt;- lapply(1:5, function(x) graph)

# Pretty TOA
names(graph) &lt;- 2001L:2005L
toa &lt;- sample(c(2001L:2005L,NA), 10, TRUE)

# Creating diffnet object
diffnet &lt;- new_diffnet(graph, toa)
diffnet
summary(diffnet)

# Plotting slice 4
plot(diffnet, t=4)

# ATTRIBUTES ----------------------------------------------------------------

# Retrieving attributes
diffnet.attrs(diffnet, "vertex", "static")

# Now as a data.frame (only static)
diffnet.attrs(diffnet, "vertex", "static", as.df = TRUE)

# Now as a data.frame (all of them)
diffnet.attrs(diffnet, as.df = TRUE)
as.data.frame(diffnet) # This is a wrapper

# Unsorted data -------------------------------------------------------------
# Loading example data
data(fakesurveyDyn)

# Creating a diffnet object
fs_diffnet &lt;- survey_to_diffnet(
   fakesurveyDyn, "id", c("net1", "net2", "net3"), "toa", "group",
   timevar = "time", keep.isolates=TRUE, warn.coercion=FALSE)

# Now, we extract the graph data and create a diffnet object from scratch
graph &lt;- fs_diffnet$graph
ids &lt;- fs_diffnet$meta$ids
graph &lt;- Map(function(g) {
  dimnames(g) &lt;- list(ids,ids)
  g
  }, g=graph)
attrs &lt;- diffnet.attrs(fs_diffnet, as.df=TRUE)
toa   &lt;- diffnet.toa(fs_diffnet)

# Lets apply a different sorting to the data to see if it works
n &lt;- nrow(attrs)
attrs &lt;- attrs[order(runif(n)),]

# Now, recreating the old diffnet object (notice -id.and.per.vars- arg)
fs_diffnet_new &lt;- new_diffnet(graph, toa=toa, vertex.dyn.attrs=attrs,
   id.and.per.vars = c("id", "per"))

# Now, retrieving attributes. The 'new one' will have more (repeated)
attrs_new &lt;- diffnet.attrs(fs_diffnet_new, as.df=TRUE)
attrs_old &lt;- diffnet.attrs(fs_diffnet, as.df=TRUE)

# Comparing elements!
tocompare &lt;- intersect(colnames(attrs_new), colnames(attrs_old))
all(attrs_new[,tocompare] == attrs_old[,tocompare], na.rm = TRUE) # TRUE!

# diffnetLapply -------------------------------------------------------------

data(medInnovationsDiffNet)
diffnetLapply(medInnovationsDiffNet, function(x, cumadopt, ...) {sum(cumadopt)})

</code></pre>


</div>