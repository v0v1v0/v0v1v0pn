<div class="container">

<table style="width: 100%;"><tr>
<td>nvertices</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Count the number of vertices/edges/slices in a graph</h2>

<h3>Description</h3>

<p>Count the number of vertices/edges/slices in a graph
</p>


<h3>Usage</h3>

<pre><code class="language-R">nvertices(graph)

nnodes(graph)

nedges(graph)

nlinks(graph)

nslices(graph)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>Any class of accepted graph format (see <code>netdiffuseR-graphs</code>).</p>
</td>
</tr></table>
<h3>Details</h3>

<p><code>nnodes</code> and <code>nlinks</code> are just aliases for <code>nvertices</code> and
<code>nedges</code> respectively.
</p>


<h3>Value</h3>

<p>For <code>nvertices</code> and <code>nslices</code>, an integer scalar equal to the number
of vertices and slices in the graph. Otherwise, from <code>nedges</code>, either a list
of size <code class="reqn">t</code> with the counts of edges (non-zero elements in the adjacency matrices) at
each time period, or, when <code>graph</code> is static, a single scalar with
such number.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Creating a dynamic graph (we will use this for all the classes) -----------
set.seed(13133)
diffnet &lt;- rdiffnet(100, 4)

# Lets use the first time period as a static graph
graph_mat &lt;- diffnet$graph[[1]]
graph_dgCMatrix &lt;- methods::as(graph_mat, "dgCMatrix")

# Now lets generate the other dynamic graphs
graph_list  &lt;- diffnet$graph
graph_array &lt;- as.array(diffnet) # using the as.array method for diffnet objects

# Now we can compare vertices counts
nvertices(diffnet)
nvertices(graph_list)
nvertices(graph_array)

nvertices(graph_mat)
nvertices(graph_dgCMatrix)

# ... and edges count
nedges(diffnet)
nedges(graph_list)
nedges(graph_array)

nedges(graph_mat)
nedges(graph_dgCMatrix)
</code></pre>


</div>