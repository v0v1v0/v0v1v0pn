<div class="container">

<table style="width: 100%;"><tr>
<td>rewire_graph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Graph rewiring algorithms</h2>

<h3>Description</h3>

<p>Changes the structure of a graph by altering ties.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rewire_graph(
  graph,
  p,
  algorithm = "endpoints",
  both.ends = FALSE,
  self = FALSE,
  multiple = FALSE,
  undirected = getOption("diffnet.undirected"),
  pr.change = ifelse(self, 0.5, 1),
  copy.first = TRUE,
  althexagons = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>Any class of accepted graph format (see <code>netdiffuseR-graphs</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Either a [0,1] vector with rewiring probabilities (<code>algorithm="endpoints"</code>),
or an integer vector with number of iterations (<code>algorithm="swap"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>Character scalar. Either <code>"swap"</code>, <code>"endpoints"</code>, or <code>"qap"</code>
(see <code>rewire_qap</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>both.ends</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> rewires both ends.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, allows loops (self edges).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> allows multiple edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>undirected</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> only the lower triangle of the adjacency matrix will considered (faster).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pr.change</code></td>
<td>
<p>Numeric scalar. Probability ([0,1]) of doing a rewire (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy.first</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> and <code>graph</code> is dynamic uses
the first slice as a baseline for the rest of slices (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>althexagons</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> uses the compact alternating
hexagons algorithm (currently ignored [on development]).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm <code>"qap"</code> is described in <code>rewire_qap</code>, and only
uses <code>graph</code> from the arguments (since it is simply relabelling the graph).
</p>
<p>In the case of "swap" and "endpoints", both algorithms are implemented
sequentially, this is, edge-wise checking self edges and multiple edges over
the changing graph; in other words, at step
<code class="reqn">m</code> (in which either a new endpoint or edge is chosen, depending on the algorithm),
the algorithms verify whether the proposed change creates either multiple edges
or self edges using the resulting graph at step <code class="reqn">m-1</code>.
</p>
<p>The main difference between the two algorithms is that the <code>"swap"</code> algorithm
preserves the degree sequence of the graph and <code>"endpoints"</code> does not.
The <code>"swap"</code> algorithm is specially useful to asses the non-randomness of
a graph's structural properties, furthermore it is this algorithm the one used
in the <code>struct_test</code> routine implemented in <span class="pkg">netdiffuseR</span>.
</p>
<p>Rewiring assumes a weighted network, hence <code class="reqn">G(i,j) = k = G(i',j')</code>,
where <code class="reqn">i',j'</code> are the new end points of the edge and <code class="reqn">k</code> may not be equal
to one.
</p>
<p>In the case of dynamic graphs, when <code>copy.first=TRUE</code>, after rewiring the
first slice–<code class="reqn">t=1</code>–the rest of slices are generated by rewiring the rewired
version of the first slice. Formally:
</p>
<p style="text-align: center;"><code class="reqn">%
G(t)' = \left\{\begin{array}{ll}
R(G(t)) &amp; \mbox{if }t=1 \\
R(G(1)') &amp; \mbox{otherwise}
\end{array}
\right.
</code>
</p>

<p>Where <code class="reqn">G(t)</code> is the t-th slice, <code class="reqn">G(t)'</code> is the t-th rewired slice, and
<code class="reqn">R</code> is the rewiring function. Otherwise, <code>copy.first=FALSE</code> (default),
The rewiring function is simply <code class="reqn">G(t)' = R(G(t))</code>.
</p>
<p>The following sections describe the way both algorithms were implemented.
</p>


<h3>Value</h3>

<p>A rewired version of the graph.
</p>


<h3>
<em>Swap</em> algorithm</h3>

<p>The <code>"swap"</code> algorithm chooses randomly two edges <code class="reqn">(a,b)</code> and
<code class="reqn">(c,d)</code> and swaps the 'right' endpoint of boths such that we get
<code class="reqn">(a,d)</code> and <code class="reqn">(c,b)</code> (considering self and multiple edges).
</p>
<p>Following Milo et al. (2004) testing procedure, the algorithm shows to be
well behaved in terms of been unbiased, so after each iteration each possible
structure of the graph has the same probability of been generated. The algorithm
has been implemented as follows:
</p>
<p>Let <code class="reqn">E</code> be the set of edges of the graph <code class="reqn">G</code>. For <code class="reqn">i=1</code> to <code class="reqn">p</code>, do:
</p>

<ol>
<li>
<p> With probability <code>1-pr.change</code> got to the last step.
</p>
</li>
<li>
<p> Choose <code class="reqn">e0=(a, b)</code> from <code class="reqn">E</code>. If <code>!self &amp; a == b</code> then go to the last step.
</p>
</li>
<li>
<p> Choose <code class="reqn">e1=(c, d)</code> from <code class="reqn">E</code>. If <code>!self &amp; c == d </code> then go to the last step.
</p>
</li>
<li>
<p> Define <code class="reqn">e0'=(a, d)</code> and <code class="reqn">e1' = (c, b)</code>. If <code>!multiple &amp; [G[e0']!= 0 | G[e1'] != 0]</code> then go to the last step.(*)
</p>
</li>
<li>
<p> Define <code class="reqn">v0 = G[e0]</code> and <code class="reqn">v1 = G[e1]</code>, set <code class="reqn">G[e0]=0</code> and <code class="reqn">G[e1]=0</code>
(and the same to the diagonally opposed coordinates in the case of undirected graphs)
</p>
</li>
<li>
<p> Set <code class="reqn">G[e0'] = v0</code> and <code class="reqn">G[e1'] = v1</code> (and so with the diagonally opposed coordinates
in the case of undirected graphs).
</p>
</li>
<li>
<p> Next i.
</p>
</li>
</ol>
<p>(*) When <code>althexagons=TRUE</code>, the algorithm changes and applies what Rao et al.
(1996) describe as Compact Alternating Hexagons. This modification assures the
algorithm to be able to achieve any structure. The algorithm consists on doing
the following swapping: <code class="reqn">(i1i2,i1i3,i2i3,i2i1,i3i1,i3i2)</code> with values
<code class="reqn">(1,0,1,0,1,0)</code> respectively with <code class="reqn">i1!=i2!=i3</code>. See the examples and
references.
</p>
<p>In Milo et al. (2004) is suggested that in order for the rewired graph to be independent
from the original one researchers usually iterate around <code>nlinks(graph)*100</code>
times, so <code>p=nlinks(graph)*100</code>. On the other hand in Ray et al (2012)
it is shown that in order to achive such it is needed to perform
<code>nlinks(graph)*log(1/eps)</code>, where <code>eps</code><code class="reqn">\sim</code>1e-7, in other words,
around <code>nlinks(graph)*16</code>. We set the default to be 20.
</p>
<p>In the case of Markov chains, the variable <code>pr.change</code> allows making the
algorithm aperiodic. This is relevant only if the
probability self-loop to a particular state is null, for example, if
we set <code>self=TRUE</code> and <code>muliple=TRUE</code>, then in every step the
algorithm will be able to change the state. For more details see
Stanton and Pinar (2012) [p. 3.5:9].
</p>


<h3>
<em>Endpoints</em> algorithm</h3>

<p>This reconnect either one or both of the endpoints of the edge randomly. As a big
difference with the swap algorithm is that this does not preserves the degree
sequence of the graph (at most the outgoing degree sequence). The algorithm is
implemented as follows:
</p>
<p>Let <code class="reqn">G</code> be the baseline graph and <code class="reqn">G'</code> be a copy of it. Then, For <code class="reqn">l=1</code> to <code class="reqn">|E|</code> do:
</p>

<ol>
<li>
<p> Pick the <code class="reqn">l</code>-th edge from <code class="reqn">E</code>, define it as <code class="reqn">e = (i,j)</code>.
</p>
</li>
<li>
<p> Draw <code class="reqn">r</code> from <code class="reqn">U(0,1)</code>, if <code class="reqn">r &gt; p</code> go to the last step.
</p>
</li>
<li>
<p> If <code>!undirected &amp; i &lt; j</code> go to the last step.
</p>
</li>
<li>
<p> Randomly select a vertex <code class="reqn">j'</code> (and <code class="reqn">i'</code> if <code>both_ends==TRUE</code>).
And define <code class="reqn">e'=(i, j')</code> (or <code class="reqn">e'=(i', j')</code> if <code>both_ends==TRUE</code>).
</p>
</li>
<li>
<p> If <code>!self &amp;</code> <code>i==j</code>' (or if <code>both_ends==TRUE &amp; i'==j'</code>) go to the last step.
</p>
</li>
<li>
<p> If <code>!multiple &amp; G'[e']!= 0</code> then go to the last step.
</p>
</li>
<li>
<p> Define <code class="reqn">v = G[e]</code>, set <code class="reqn">G'[e] = 0</code> and <code class="reqn">G'[e'] = v</code> (and the
same to the diagonally opposed coordinates in the case of undirected graphs).
</p>
</li>
<li>
<p> Next <code class="reqn">l</code>.
</p>
</li>
</ol>
<p>The endpoints algorithm is used by default in <code>rdiffnet</code> and used
to be the default in <code>struct_test</code> (now <code>swap</code> is the default).
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collectivedynamics of "small-world" networks.
Nature, 393(6684), 440–442. <a href="https://doi.org/10.1038/30918">doi:10.1038/30918</a>
</p>
<p>Milo, R., Kashtan, N., Itzkovitz, S., Newman, M. E. J., &amp; Alon, U.
(2004). On the uniform generation of random graphs with prescribed degree sequences.
Arxiv Preprint condmat0312028, cond-mat/0, 1–4. Retrieved from
<a href="https://arxiv.org/abs/cond-mat/0312028">https://arxiv.org/abs/cond-mat/0312028</a>
</p>
<p>Ray, J., Pinar, A., and Seshadhri, C. (2012).
Are we there yet? When to stop a Markov chain while generating random graphs.
pages 1–21.
</p>
<p>Ray, J., Pinar, A., &amp; Seshadhri, C. (2012). Are We There Yet? When to Stop a
Markov Chain while Generating Random Graphs. In A. Bonato &amp; J. Janssen (Eds.),
Algorithms and Models for the Web Graph (Vol. 7323, pp. 153–164).
Berlin, Heidelberg: Springer Berlin Heidelberg.
<a href="https://doi.org/10.1007/978-3-642-30541-2">doi:10.1007/978-3-642-30541-2</a>
</p>
<p>A . Ramachandra Rao, R. J. and S. B. (1996). A Markov Chain Monte Carlo Method
for Generating Random ( 0 , 1 ) -Matrices with Given Marginals. The Indian
Journal of Statistics, 58, 225–242.
</p>
<p>Stanton, I., &amp; Pinar, A. (2012). Constructing and sampling graphs with a
prescribed joint degree distribution. Journal of Experimental Algorithmics,
17(1), 3.1. <a href="https://doi.org/10.1145/2133803.2330086">doi:10.1145/2133803.2330086</a>
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code>permute_graph()</code>,
<code>rdiffnet()</code>,
<code>rgraph_ba()</code>,
<code>rgraph_er()</code>,
<code>rgraph_ws()</code>,
<code>ring_lattice()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Checking the consistency of the "swap" ------------------------------------

# A graph with known structure (see Milo 2004)
n &lt;- 5
x &lt;- matrix(0, ncol=n, nrow=n)
x &lt;- as(x, "dgCMatrix")
x[1,c(-1,-n)] &lt;- 1
x[c(-1,-n),n] &lt;- 1

x

# Simulations (increase the number for more precision)
set.seed(8612)
nsim &lt;- 1e4
w &lt;- sapply(seq_len(nsim), function(y) {
 # Creating the new graph
 g &lt;- rewire_graph(x,p=nlinks(x)*100, algorithm = "swap")

 # Categorizing (tag of the generated structure)
 paste0(as.vector(g), collapse="")
})

# Counting
coded &lt;- as.integer(as.factor(w))

plot(table(coded)/nsim*100, type="p", ylab="Frequency %", xlab="Class of graph", pch=3,
 main="Distribution of classes generated by rewiring")

# Marking the original structure
baseline &lt;- paste0(as.vector(x), collapse="")
points(x=7,y=table(as.factor(w))[baseline]/nsim*100, pch=3, col="red")

</code></pre>


</div>