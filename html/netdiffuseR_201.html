<div class="container">

<table style="width: 100%;"><tr>
<td>rgraph_ws</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Watts-Strogatz model</h2>

<h3>Description</h3>

<p>Generates a small-world random graph.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rgraph_ws(
  n,
  k,
  p,
  both.ends = FALSE,
  self = FALSE,
  multiple = FALSE,
  undirected = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer scalar. Set the size of the graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Integer scalar. Set the initial degree of the ring (must be less than <code class="reqn">n</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Numeric scalar/vector of length <code class="reqn">T</code>. Set the probability of changing an edge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>both.ends</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> rewires both ends.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, allows loops (self edges).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> allows multiple edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>undirected</code></td>
<td>
<p>Logical scalar. Passed to <code>ring_lattice</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Implemented as in Watts and Strogatz (1998). Starts from an
undirected ring with <code class="reqn">n</code> vertices all with degree <code class="reqn">k</code> (so it must
be an even number), and then rewire each edge by setting the endpoint (so
now you treat it as a digraph) randomly any vertex in <code class="reqn">N \setminus {i}</code>
avoiding multiple links (by default) using the rewiring algorithm described on
the paper.
</p>


<h3>Value</h3>

<p>A random graph of size <code class="reqn">n\times n</code> following the small-world
model. The resulting graph will have <code>attr(graph, "undirected")=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collective dynamics of "small-world"
networks. Nature, 393(6684), 440–2. <a href="https://doi.org/10.1038/30918">doi:10.1038/30918</a>
</p>
<p>Newman, M. E. J. (2003). The Structure and Function of Complex Networks.
SIAM Review, 45(2), 167–256. <a href="https://doi.org/10.1137/S003614450342480">doi:10.1137/S003614450342480</a>
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code>permute_graph()</code>,
<code>rdiffnet()</code>,
<code>rewire_graph()</code>,
<code>rgraph_ba()</code>,
<code>rgraph_er()</code>,
<code>ring_lattice()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(igraph)
set.seed(7123)
x0 &lt;- graph_from_adjacency_matrix(rgraph_ws(10,2, 0))
x1 &lt;- graph_from_adjacency_matrix(rgraph_ws(10,2, .3))
x2 &lt;- graph_from_adjacency_matrix(rgraph_ws(10,2, 1))

oldpar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3))
plot(x0, layout=layout_in_circle, edge.curved=TRUE, main="Regular")
plot(x1, layout=layout_in_circle, edge.curved=TRUE, main="Small-world")
plot(x2, layout=layout_in_circle, edge.curved=TRUE, main="Random")
par(oldpar)

</code></pre>


</div>