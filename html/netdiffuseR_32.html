<div class="container">

<table style="width: 100%;"><tr>
<td>rgraph_er</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Erdos-Renyi model</h2>

<h3>Description</h3>

<p>Generates a bernoulli random graph.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rgraph_er(
  n = 10,
  t = 1,
  p = 0.01,
  undirected = getOption("diffnet.undirected"),
  weighted = FALSE,
  self = getOption("diffnet.self"),
  as.edgelist = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer. Number of vertices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>Integer. Number of time periods</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Double. Probability of a link between ego and alter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>undirected</code></td>
<td>
<p>Logical scalar. Whether the graph is undirected or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted</code></td>
<td>
<p>Logical. Whether the graph is weighted or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>self</code></td>
<td>
<p>Logical. Whether it includes self-edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.edgelist</code></td>
<td>
<p>Logical. When TRUE the graph is presented as an edgelist
instead of an adjacency matrix.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For each pair of nodes <code class="reqn">\{i,j\}</code>, an edge is created
with probability <code class="reqn">p</code>, this is, <code class="reqn">Pr\{Link i-j\} = Pr\{x&lt;p\}</code>, where <code class="reqn">x</code> is drawn from a <code class="reqn">Uniform(0,1)</code>.
</p>
<p>When <code>weighted=TRUE</code>, the strength of ties is given by
the random draw <code class="reqn">x</code> used to compare against <code class="reqn">p</code>, hence, if <code class="reqn">x &lt; p</code>
then the strength will be set to <code class="reqn">x</code>.
</p>
<p>In the case of dynamic graphs, the algorithm is repeated <code class="reqn">t</code> times, so the
networks are uncorrelated.
</p>


<h3>Value</h3>

<p>A graph represented by an adjacency matrix (if <code>t=1</code>), or an array of
adjacency matrices (if <code>t&gt;1</code>).
</p>


<h3>Note</h3>

<p>The resulting adjacency matrix is store as a dense matrix, not as a
sparse matrix, hence the user should be careful when choosing the size of
the network.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Barabasi, Albert-Laszlo. "Network science book" Retrieved November 1 (2015)
<a href="https://barabasi.com/book/network-science">https://barabasi.com/book/network-science</a>.
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code>permute_graph()</code>,
<code>rdiffnet()</code>,
<code>rewire_graph()</code>,
<code>rgraph_ba()</code>,
<code>rgraph_ws()</code>,
<code>ring_lattice()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Setting the seed
set.seed(13)

# Generating an directed graph
rgraph_er(undirected=FALSE, p = 0.1)

# Comparing P(tie)
x &lt;- rgraph_er(1000, p=.1)
sum(x)/length(x)

# Several period random gram
rgraph_er(t=5)
</code></pre>


</div>