<div class="container">

<table style="width: 100%;"><tr>
<td>AMME</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function to estimate the average micro mediated effect (AMME).</h2>

<h3>Description</h3>

<p><code>AMME</code> implements parametric and nonparametric estimation routines to estimate the
average mediated micro effect. It requires two models. The first is a generative network model (i.e., a model where the dyad, dyad-time period, or dyad-group is the unit of analysis) of the form <code class="reqn">f(A_{ij}|T_{ij},Z_{ij})</code>, where <code class="reqn">A</code> is a cross-sectional or longitudinal network or group of longitudinal or cross-sectional networks, <code class="reqn">T</code> is the possibly endogenous network selection process of interest and <code class="reqn">Z</code> is a matrix of possibly endogenous confounding selection mechanisms.
</p>
<p>The second model is a cross-sectional or longitudinal macro model (i.e., a model where the unit of analysis is a node, subgraph, or network or a combination of nodes, subgraphs, and networks measured collected from multiple settings [such as distinct schools or organizations]) of the form <code class="reqn">g(Y_i|M_{i},X_{i},T_{i})</code>, where <code class="reqn">Y_i</code> is the outcome variable, <code class="reqn">M_i</code> is the mediating macro variable,  <code class="reqn">X_i</code> is a matrix of control variables that possibly vary as a function of selection process <code class="reqn">T_{ij}</code>, and <code class="reqn">T_i</code> is the optional unit-level measure of <code class="reqn">T_{ij}</code>. The AMME is the change in <code class="reqn">Y_i</code> when <code class="reqn">T_{ij}</code> allowed to vary versus set to 0 because of an associated change in <code class="reqn">M_i</code>. The AMME is given by </p>
<p style="text-align: center;"><code class="reqn">AMME=\frac{1}{2n} y_i(T_i(t),M_i(T_{ij}),X_i(t))-y_i(T_i(t),M_i(0),X_i(t))</code>
</p>
<p>, where <code class="reqn">n</code> is the number of observations and <code class="reqn">t=0,T_{ij}</code>. AMME currently accepts the following micro models: <code>glm</code>, <code>glmer</code>, <code>ergm</code>, <code>btergm</code>, <code>sienaFit</code>, <code>rem.dyad</code>, and <code>netlogit</code> objects. The following macro model objects are accepted: <code>lm</code>, <code>glm</code>, <code>lmer</code>, <code>glmer</code>, <code>gam</code>, <code>plm</code>, and <code>lnam</code> objects. Pooled estimation for multiple network models is also implemented for <code>ergm</code> and <code>sienaFit</code> micro models. Both parametric and nonparametric estimation are available.
</p>


<h3>Usage</h3>

<pre><code class="language-R">AMME(micro_model,
      macro_model,
      micro_process,
      mediator,
      macro_function,
      link_id,
      object_type=NULL,
      controls=NULL,
      control_functions=NULL,
      interval=c(0,1),
      nsim=500,
      algorithm="parametric",
      silent=FALSE,
      full_output=FALSE,
      SAOM_data=NULL,
      SAOM_var=NULL,
      time_interval=NULL,
      covar_list=NULL,
      edgelist=NULL,
      net_logit_y=NULL,
      net_logit_x=NULL,
      group_id=NULL,
      node_numbers=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>micro_model</code></td>
<td>
<p>the micro-model. Currently accepts <code>glm</code>, <code>glmer</code>, <code>ergm</code>, <code>btergm</code>, <code>sienaFit</code>, <code>rem.dyad</code>, and <code>netlogit</code> objects. Pooled estimation for multiple network models is also implemented for <code>ergm</code> and <code>sienaFit</code> objects. To implement pooled estimation, <code>model</code> should be provided as a list of <code>ergm</code> or <code>sienaFit</code> objects.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>macro_model</code></td>
<td>
<p>the macro model. Currently accepts <code>lm</code>, <code>glm</code>, <code>lmer</code>, <code>glmer</code>, <code>gam</code>, <code>plm</code>, and <code>lnam</code> objects.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>micro_process</code></td>
<td>
<p>a character string containing the name of the micro process of interest. The character string should exactly match the relevant coefficient name in <code>micro_model</code> output.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mediator</code></td>
<td>
<p>a character string containing the name of the mediating variable of interest.  The character string should exactly match the relevant coefficient name in <code>macro_model</code> output.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>macro_function</code></td>
<td>
<p>a <code>function</code> that calculates <code>mediator</code> on the simulated networks. Currently accepts user defined functions as well as functions inherent in the <code>igraph</code> and <code>statnet</code> packages for <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link_id</code></td>
<td>
<p>a required vector of IDs used to link the <code>micro_model</code> output to the <code>macro_model</code> input. If calculating a network-level mediator, this should be the network identifier or network-group/network-time period identifier. If calculating a node-level mediator, this should be the node ID or node-time-period/node-group identifier. Observations should correspond exactly to rows in the <code>macro_model</code> data matrix. If calculating multiple network statistics at different levels of analysis when <code>controls</code> are included, <code>link_id</code> may be provided as an ordered list of identifiers. In this case, each entry in the list is a vector of IDs corresponding to the unique entries of the relevant statistics. If provided as a list, the first entry should correspond to <code>macro_function</code> (i.e., the mediator) and the remaining entries should correspond to <code>control_functions</code> (i.e., the controls).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>controls</code></td>
<td>
<p>a vector of character strings listing the control variables in <code>macro_model</code> that may vary as a function of <code>micro_process</code>. Each element in <code>controls</code> should correspond exactly to a coefficient in <code>macro_model</code> output. If <code>controls</code> is left <code>NULL</code>,then the AMME is calculated without controlling for confounding network variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control_functions</code></td>
<td>
<p>a list of functions used to calculate <code>controls</code>. The elements in <code>control_functions</code> should correspond exactly to the elements in <code>controls</code> and should be provided in the same order. If <code>micro_process</code> appears as an independent variable in <code>macro_model</code>, then this can be specified by specifying the <code>netmediate</code> helper function <code>identity_function</code> to <code>control_functions</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object_type</code></td>
<td>
<p>A character string or vector of character strings that tells <code>netmediate</code> the type of object to apply the <code>macro_function</code> and <code>control_functions</code> to. If <code>controls</code> are included into the <code>AMME</code> call, then <code>object_type</code> should be provided as a vector of character strings where the first element is the <code>object_type</code> for <code>macro_function</code> and the remaining elements are the ordered <code>object_type</code> for <code>control_functions</code>. Currently accepts <code>igraph</code> and <code>network</code> objects. If left <code>NULL</code>, <code>network</code> objects are assumed. Can be over-ridden to use other object types with a user-function by defining a function that accepts either a <code>network</code> or <code>igraph</code> object and returns a numeric value or vector of numeric values (see examples).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>Tuning parameters to vary the strength of <code class="reqn">\theta</code>. Should be provided as a vector of numeric values with 2 entries.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>The number of simulations or bootstrap samples to use during estimation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>The estimation algorithm to be used. Currently accepts <code>"parametric"</code> and <code>"nonparametric"</code>. If <code>"parametric"</code>, estimation is obtained with Monte Carlo sampling. If <code>"nonparametric"</code>, estimation uses bootstrap resampling.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>logical parameter. Whether to provide updates on the progress of the simulation or not.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full_output</code></td>
<td>
<p>logical parameter. If set to <code>TRUE</code>, the entire distribution of simulated statistics will be provided as part of the model output.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAOM_data</code></td>
<td>
<p>required when <code>micro_model</code> is a <code>sienaFit</code> object; ignored otherwise. If a <code>sienaFit</code> object is provided, <code>SAOM_data</code> should be the <code>siena</code> object that contains the data for SAOM estimation. If using pooled estimation on multiple <code>sienaFit</code> objects (i.e., providing a list of <code>sienaFit</code> objects), then <code>SAOM_data</code> should be provided as an ordered list with each entry containing the <code>siena</code> object corresponding to list of <code>sienaFit</code> objects.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAOM_var</code></td>
<td>
<p>optional parameter when <code>micro_model</code> is a <code>sienaFit</code> object. <code>SAOM_var</code> is a list of of the <code>varCovar</code> and <code>varDyadCovar</code> objects used to assign time varying node and dyad covariates when calling <code>sienaDataCreate</code>. If provided, <code>netmediate</code> assigns the varying node covariates and dyad covariates to each simulated network. This parameter is required when <code>macro_function</code> computes a statistic that varies as a function of time varying node or dyad covariates (i.e., network segregation, assorativity). Time invariant characteristics (<code>coCovar</code> and <code>coDyadCovar</code>) are handled internally by <code>MEMS</code> and should not be provided. When providing a list of <code>sienaFit</code> objects for pooled estimation, <code>SAOM_var</code> should be provided as a list of lists, where each entry in the list contains a list of <code>varCovar</code> and <code>varDyadCovar</code> objects associated with corresponding <code>sienaFit</code> object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_interval</code></td>
<td>
<p>an optional parameter to be used when <code>micro_model</code> is a  <code>rem.dyad</code> object. May be provided as a numeric vector or the character string <code>"aggregate"</code>. If a numeric vector is provided unique network snapshots at each interval. For example, <code>time_interval=c(0,2,3)</code> would induce two networks, one for the 0 - 2 time period and one for the 2 - 3 time period. If specified as <code>"aggregate"</code>, the AMME is calculated by creating an aggregated cross-sectional representation of the entire event sequence. If left <code>NULL</code>, defaults to |<code>"aggregate"</code>. Note that <code>time_interval</code> must correspond to the time periods observed in <code>macro_model</code>. That is, <code>time_interval</code> must be set to <code>"aggregate"</code> when <code>macro_model</code> is cross-sectional and the entries in <code>time_interval</code> must correspond to the time periods observed in the repeated measurement data when <code>macro_model</code> is longitudinal.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covar_list</code></td>
<td>
<p>an optional list of sender/receiver covariates used in <code>rem.dyad</code> estimation. Only required when a <code>rem.dyad</code> object is the <code>micro_model</code> and covariates are in the <code>rem.dyad</code> call. The list format should correspond to the format required by <code>rem.dyad</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edgelist</code></td>
<td>
<p>an optional three column edgelist providing the sender, receiver, and time of event occurrence when <code>micro_model</code> is a <code>rem.dyad</code> object. Only required when <code>time_interval</code> is set to <code>NULL</code> or <code>"aggregate"</code>. Ignored for other types of models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>net_logit_y</code></td>
<td>
<p>the dependent variable when <code>micro_model</code> is a <code>netlogit</code> object. Should be provided as a vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>net_logit_x</code></td>
<td>
<p>the matrix of independent variables when <code>micro_model</code> is a <code>netlogit</code> object
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_id</code></td>
<td>
<p>optional vector of group identifiers to use when <code>micro_model</code> is a <code>glm</code> or <code>glmer</code> on grouped data (i.e., multiple time periods, multiple networks). When specified,  <code>AMME</code> will induce unique networks for each grouping factor. If left unspecified, all groups/time periods are pooled. If using <code>glmer</code>, the grouping factor does not have to be provided as part of the model or used as a random effect. If specified, the entries in the <code>macro_model</code> model matrix are assumed to be sequentially ordered by unit_id-group_id.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node_numbers</code></td>
<td>
<p>a numeric vector containing the number of nodes in each group_id when using <code>glm</code> or <code>glmer</code>. If estimating AMME aggregated over all networks (i.e., <code>group_id=NULL</code>), this shoud be the total number of nodes in all networks. Required when using <code>glm</code> or <code>glmer</code>, ignored otherwise.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Estimates the AMME over the provided intervals. Standard errors and confidence intervals are based on the sampling distribution of simulated values, which are calculated either parametrically or nonparametrically according to <code>algorithm</code>. Parametric estimation is typically faster, but cannot be used for nonparametric network models (e.g., quadratic assignment procedure).
</p>
<p><code>macro_function</code> and <code>control_functions</code> make up the core utilites of <code>AMME</code>. <code>macro_function</code> calculates the mediating variable of interest, while <code>control_functions</code> calculates all control variables that vary as a function of <code>micro_process</code> and potentially confound the effect of <code>mediator</code>. When <code>controls</code> are left <code>NULL</code>, then <code>AMME</code> estimates the AMME without accounting for confounding variables. Specifying <code>controls</code> and <code>control_functions</code> ensures that estimates of the AMME account for alternative pathways from <code>micro_process</code> to the outcome variable in <code>macro_model</code>. In cases where <code>micro_process</code> is included as a predictor variable in <code>macro_model</code>, this can be specified by including the <code>netmediate</code> helper function <code>identity_function</code> into <code>control_functions</code>.
</p>
<p><code>netmediate</code> currently supports functions calculated on <code>igraph</code> and <code>network</code> objects, which should be specified using the <code>object_type</code> argument. These may be functions inherent to the <code>statnet</code> and <code>igraph</code> software package or they may be functions from other packages that accept <code>network</code>/<code>igraph</code> objects. The functions provided to <code>macro_function</code> and <code>control_functions</code> may also be user-defined functions that accept <code>network</code> or <code>igraph</code> objects as inputs and return a numeric value or vector of numeric values as output. It is also possible to over-ride the <code>network</code> and <code>igraph</code> object requirements within a user function. To do so, set the <code>object_type</code> argument (or relevant element within the <code>object_type</code> argument when <code>object_type</code> is a list) to either <code>network</code> or <code>igraph</code> and then define a user-function that accepts a <code>network</code> or <code>igraph</code> object as its input, converts the object to the desired data structure, calculates the statistic of interest, and  returns a numeric value or vector of numeric values. See examples below for an illustration.
</p>
<p>By default, the AMME is calculated by averaging over the distribution of simulated values. If <code>full_output</code> is set to <code>TRUE</code>, the distribution of simualted statistics is returned. This may be useful when the median or mode of the simulated distribution is required or if the researcher wants to inspect the distributional shape of simulated values.
</p>
<p><code>AMME</code> also supports pooled estimation for when multiple <code>ergm</code> or <code>sienaFit</code> objects are used as the <code>micro_model</code>. To use pooled estimation, the model parameter should be specified as a list of <code>ergm</code> or <code>sienaFit</code> objects. If using <code>sienaFit</code>, the <code>SAOM_data</code> argument will also need to be specified as an ordered list with elements corresponding to entries in the list of <code>sienaFit</code> objects. Similarly, the <code>SAOM_var</code> parameter will need to be specified as a list of lists, where each entry in the list is, itself, a list containing all <code>varCovar</code> and <code>varDyadCovar</code> objects used to calculate macro statistics of interest. Note that <code>SAOM_var</code> should not be provided if the macro statistic of interest is not a function of the variables contained in <code>varCovar</code> and <code>varDyadCovar</code>.
</p>


<h3>Value</h3>

<p>If <code>full_output=FALSE</code>, then a table is returned with the AMME, its standard error, confidence interval, and p-value.
</p>
<p>If <code>full_output=TRUE</code>, then a list is returned with the following three elements.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>summary_dat</code></td>
<td>
<p>is the table of summary output ucontaining the AMME, its standard error, confidence interval, and p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AMME_obs</code></td>
<td>
<p>is vector of observations where each entry is the AMME for a single simulation trial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop_explained_obs</code></td>
<td>
<p>is vector containing the proportion explained values for each simulation trial.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Duxbury, Scott W. Associate Professor, University of North Carolinaâ€“Chapel Hill, Department of Sociology.
</p>


<h3>References</h3>

<p>Duxbury, Scott W. 2024. "Micro-macro Mediation Analysis in Social Networks." Sociological Methodology.
</p>


<h3>See Also</h3>

<p><code>MEMS</code>
<code>ergm.mma</code>
<code>mediate</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

##############################
#   Basic AMME specifications
#############################


####create ERGM generative model
library(statnet)
data("faux.mesa.high")
ergm_model&lt;-ergm(faux.mesa.high~edges+
                   nodecov("Grade")+
                   nodefactor("Race")+
                   nodefactor("Sex")+
                   nodematch("Race")+
                   nodematch("Sex")+
                   absdiff("Grade"))


###create node-level data for second stage analysis with
node_level_data&lt;-data.frame(grade=faux.mesa.high%v%"Grade",
                            race=faux.mesa.high%v%"Race",
                            sex=faux.mesa.high%v%"Sex",
                            degree=degree(faux.mesa.high))

node_level_data$senior&lt;-0
node_level_data$senior[node_level_data$grade==max(node_level_data$grade)]&lt;-1
node_level_data$v_id&lt;-1:network.size(faux.mesa.high) #define ID for each observation

probit_model&lt;-glm(senior~race+sex+degree,
                data=node_level_data,
                family=binomial(link="probit"))

###estimate the indirect effect of grade homophily on senior status acting through degree centrality
  #in a model with no network control variables
AMME(micro_model=ergm_model,
     macro_model=probit_model,
     micro_process="absdiff.Grade",
     mediator="degree",
     macro_function=degree,
     link_id=node_level_data$v_id, #specify vertex IDs
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)

#use nonparametric estimation for a generalized additive model
library(gam)

gam_model&lt;-gam(senior~race+sex+s(degree),
               data=node_level_data)

AMME(micro_model=ergm_model,
     macro_model=gam_model,
     micro_process="absdiff.Grade",
     mediator="s(degree)",
     macro_function=degree,
     link_id=node_level_data$v_id,
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="nonparametric",
     silent=FALSE)



###estimate AMME with linear network autocorrelation model

lnam_model&lt;-lnam(node_level_data$grade,
                 x=as.matrix(node_level_data[,4:5]),
                 W1=as.sociomatrix(faux.mesa.high))


AMME(micro_model=ergm_model,
     macro_model=lnam_model,
     micro_process="absdiff.Grade",
     mediator="degree",
     macro_function=degree,
     link_id=node_level_data$v_id,
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)




############################
#   Including controls
###########################

##single control
node_level_data&lt;-data.frame(grade=faux.mesa.high%v%"Grade",
                            race=faux.mesa.high%v%"Race",
                            sex=faux.mesa.high%v%"Sex",
                            degree=degree(faux.mesa.high),
                            betweenness=betweenness(faux.mesa.high))

node_level_data$senior&lt;-0
node_level_data$senior[node_level_data$grade==max(node_level_data$grade)]&lt;-1
node_level_data$v_id&lt;-1:network.size(faux.mesa.high) #define ID for each observation

probit_model&lt;-glm(senior~race+sex+degree+betweenness,
                  data=node_level_data,
                  family=binomial(link="probit"))


AMME(micro_model=ergm_model,
     macro_model=probit_model,
     micro_process="absdiff.Grade",
     mediator="degree",
     macro_function=degree,
     link_id=node_level_data$v_id, #specify vertex IDs
     controls="betweenness", #should match model output exactly
     control_functions=betweenness,
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)



##multiple controls
##include an AR 1 parameter to make it a nonlinear network autocorrelation model
node_level_data$AR1&lt;-as.sociomatrix(faux.mesa.high)%*%node_level_data$senior
probit_model&lt;-glm(senior~race+sex+degree+betweenness+AR1,
                  data=node_level_data,
                  family=binomial(link="probit"))

#specify user function
ar_function&lt;-function(x){
  return(as.sociomatrix(x)%*%node_level_data$senior)
}


AMME(micro_model=ergm_model,
     macro_model=probit_model,
     micro_process="absdiff.Grade",
     mediator="degree",
     macro_function=degree,
     link_id=node_level_data$v_id,
     controls=c("betweenness","AR1"), #should match model output exactly
     control_functions=list(betweenness,ar_function), #provide functions as a list
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)



##using identity_function when micro_process has a direct effect on y
  #to use identity_function, the control and micro_process need to have the same
  #name and the macro control variable has to be numeric

node_level_data$Sex&lt;-as.numeric(as.factor(node_level_data$sex))
logit_model&lt;-glm(senior~race+Sex+degree+betweenness+AR1,
                  data=node_level_data,
                  family=binomial)



AMME(micro_model=ergm_model,
     macro_model=logit_model,
     micro_process="nodefactor.Sex.M",
     mediator="degree",
     macro_function=degree,
     link_id=node_level_data$v_id,
     controls=c("betweenness","AR1","Sex"), #should match model output exactly
     control_functions=list(betweenness,ar_function,identity_function),
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)





################################
#   More complex data structures
###############################


###############################
# AMME with longitudinal data
##############################

#bootstrap TERGM and panel data model
library(btergm)
library(plm)
data(alliances)

ally_data&lt;-list(LSP[[1]],
                LSP[[2]],
                LSP[[3]])

#fit bootstrap TERGM with 200 replications
bt_model&lt;-btergm(ally_data~edges+
                   gwesp(.7,fixed=T)+
                   mutual,R=200)


#create node data
ally_node_data&lt;-data.frame(outdeg=c(rowSums(LSP[[1]]),rowSums(LSP[[2]]),rowSums(LSP[[3]])),
                           indeg=c(colSums(LSP[[1]]),colSums(LSP[[2]]),colSums(LSP[[3]])))

ally_node_data$v_id&lt;-rep(rownames(LSP[[1]]),3) #create node IDS
ally_node_data$t_id&lt;-c(rep(1, nrow(ally_data[[1]])), #create time IDS
                       rep(2, nrow(ally_data[[1]])),
                       rep(3, nrow(ally_data[[1]])))
ally_node_data$link_id&lt;-paste(ally_node_data$v_id,ally_node_data$t_id)#create node-panel identifiers

ally_node_data$v_id&lt;-as.factor(as.character(ally_node_data$v_id))

#estimate a linear model with node fixed effects
lm_model&lt;- lm(outdeg~indeg +v_id,
          data = ally_node_data)



AMME(micro_model=bt_model,
     macro_model=lm_model,
     micro_process="gwesp.OTP.fixed.0.7",
     mediator="indeg",
     macro_function=function(x){degree(x,cmode="indegree")},
     link_id=ally_node_data$link_id, #provide node-panel identifiers
     object_type="network",
     interval=c(0,1),
     nsim=11,
     algorithm="nonparametric",
     silent=FALSE)


##include controls at different units of analysis
  #include global transitivity statistic at each network panel
transitivity_list&lt;-c(gtrans(as.network(LSP[[1]])),
                     gtrans(as.network(LSP[[2]])),
                     gtrans(as.network(LSP[[3]])))


ally_node_data$transitivity&lt;-c(rep(transitivity_list[1],nrow(LSP[[1]])),
                               rep(transitivity_list[2],nrow(LSP[[2]])),
                               rep(transitivity_list[3],nrow(LSP[[3]])))



lm_model&lt;- lm(outdeg~indeg+transitivity +v_id,
              data = ally_node_data)



AMME(micro_model=bt_model,
     macro_model=lm_model,
     micro_process="gwesp.OTP.fixed.0.7",
     mediator="indeg",
     macro_function=function(x){degree(x,cmode="indegree")},
     link_id=list(ally_node_data$link_id,ally_node_data$t_id),#list of IDs for nodes and time
     controls="transitivity",
     control_functions = gtrans,
     object_type="network",
     interval=c(0,1),
     nsim=11,
     algorithm="nonparametric",
     silent=FALSE)




#SAOM and panel data model with PLM package
library(RSiena)
#specify 3 wave network panel data as DV
network_list&lt;-array(c(s501,s502,s503),dim = c(50,50,3))

Network&lt;-sienaDependent(network_list)
Smoking&lt;-varCovar(s50s)
Alcohol&lt;-varCovar(s50a)
SAOM.Data&lt;-sienaDataCreate(Network=Network,Smoking,Alcohol)

#specify
SAOM.terms&lt;-getEffects(SAOM.Data)
SAOM.terms&lt;-includeEffects(SAOM.terms,egoX,altX,sameX,interaction1="Alcohol")
SAOM.terms&lt;-includeEffects(SAOM.terms,egoX,altX,sameX,interaction1="Smoking")
SAOM.terms&lt;-includeEffects(SAOM.terms,transTies,inPop)


create.model&lt;-sienaAlgorithmCreate(projname="netmediate",
                                   nsub=5,
                                   n3=2000)


##estimate the SAOM
SAOM_model&lt;-siena07(create.model,
                        data=SAOM.Data,
                        effects=SAOM.terms,
                        verbose=TRUE)


##create node-level data
node_level_data&lt;-data.frame(smoking=s50s[,1], #smoking behavior for DV
                            alcohol=s50a[,1],
                            v_id=rownames(s501), #unique node IDS
                            wave="Wave 1",       #unique time IDS
                            outdegree=rowSums(s501),
                            indegree=colSums(s501),
                            AR1=s501%*%s50s[,1],  #assign network autocorrelation
                            gcc=gtrans(as.network(s501)))

node_level_data&lt;-rbind(node_level_data,data.frame(smoking=s50s[,2],
                                                  alcohol=s50a[,2],
                                                  v_id=rownames(s502),
                                                  wave="Wave 2",
                                                  outdegree=rowSums(s502),
                                                  indegree=colSums(s502),
                                                  AR1=s502%*%s50s[,2],
                                                  gcc=gtrans(as.network(s502))))



node_level_data&lt;-rbind(node_level_data,data.frame(smoking=s50s[,3],
                                                  alcohol=s50a[,3],
                                                  v_id=rownames(s503),
                                                  wave="Wave 3",
                                                  outdegree=rowSums(s503),
                                                  indegree=colSums(s503),
                                                  AR1=s503%*%s50s[,3],
                                                  gcc=gtrans(as.network(s503))))


##create unique identifiers for node-panel
node_level_data$unique_ids&lt;-paste(node_level_data$v_id,node_level_data$wave)

##estimate one-way fixed effects model with PLM
library(plm)
FE_model&lt;-plm(smoking~alcohol+outdegree+indegree+AR1+gcc,
               data=node_level_data,
               index=c("v_id","wave"))



##create AR function to provide to AMME
ar_function&lt;-function(x){return(as.sociomatrix(x)%*%(x%v%"Smoking"))}


AMME(micro_model=SAOM_model,
     macro_model=FE_model,
     micro_process="reciprocity",
     mediator="indegree",
     macro_function=function(x){degree(x,cmode="indegree")},
     link_id=list(node_level_data$unique_id,node_level_data$unique_id,
                      node_level_data$unique_id,node_level_data$wave),
     object_type="network",
     controls=c("outdegree","AR1","gcc"),
     control_functions=list(function(x){degree(x,cmode="outdegree")},ar_function,gtrans),
     interval=c(0,.1),
     nsim=500,
     algorithm="parametric",
     silent=FALSE,
     SAOM_data = SAOM.Data,
     SAOM_var=list(Smoking=Smoking,Alcohol=Alcohol)) #provide var_list






################################
# AMME with pooled ERGM and SAOM
################################



#pooled ERGM
  #fit two ERGMs to two networks
data("faux.mesa.high")
model1&lt;-ergm(faux.mesa.high~edges+
               nodecov("Grade")+
               nodefactor("Race")+
               nodefactor("Sex")+
               nodematch("Race")+
               nodematch("Sex")+
               absdiff("Grade"))

data("faux.magnolia.high")
model2&lt;-ergm(faux.magnolia.high~edges+
               nodecov("Grade")+
               nodefactor("Race")+
               nodefactor("Sex")+
               nodematch("Race")+
               nodematch("Sex")+
               absdiff("Grade"))


#create node level data
node_level_data&lt;-data.frame(grade=faux.mesa.high%v%"Grade",
                            sex=faux.mesa.high%v%"Sex",
                            degree=degree(faux.mesa.high),
                            betweenness=betweenness(faux.mesa.high),
                            gcc=gtrans(faux.mesa.high),
                            net_id="Mesa")

node_level_data$senior&lt;-0
node_level_data$senior[node_level_data$grade==max(node_level_data$grade)]&lt;-1
node_level_data$v_id&lt;-1:network.size(faux.mesa.high)


node_level_data2&lt;-data.frame(grade=faux.magnolia.high%v%"Grade",
                            sex=faux.magnolia.high%v%"Sex",
                            degree=degree(faux.magnolia.high),
                            betweenness=betweenness(faux.magnolia.high),
                            gcc=gtrans(faux.magnolia.high),
                            net_id="Magnolia")

node_level_data2$senior&lt;-0
node_level_data2$senior[node_level_data$grade==max(node_level_data2$grade)]&lt;-1
node_level_data2$v_id&lt;-206:(network.size(faux.magnolia.high)+205)
node_level_data&lt;-rbind(node_level_data,node_level_data2)


#estimate glm macro model with an AR 1 process
probit_model&lt;-glm(senior~sex+degree+betweenness+gcc,
                data=node_level_data,
                family=binomial(link="probit"))



AMME(micro_model=list(model1,model2),
     macro_model=probit_model,
     micro_process="nodematch.Sex",
     mediator="degree",
     macro_function=degree,
     link_id=list(node_level_data$v_id,node_level_data$v_id,node_level_data$net_id),
     object_type="network",
     controls=c("betweenness","gcc"),
     control_functions=list(betweenness,gtrans),
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)



##pooled SAOM with control functions using time varying covariates

library(RSiena)
#specify 3 wave network panel data as DV
network_list&lt;-array(c(s501,s502,s503),dim = c(50,50,3))

Network&lt;-sienaDependent(network_list)
Smoking&lt;-varCovar(s50s)
Alcohol&lt;-varCovar(s50a)
SAOM.Data&lt;-sienaDataCreate(Network=Network,Smoking,Alcohol)

#specify
SAOM.terms&lt;-getEffects(SAOM.Data)
SAOM.terms&lt;-includeEffects(SAOM.terms,egoX,altX,sameX,interaction1="Alcohol")
SAOM.terms&lt;-includeEffects(SAOM.terms,egoX,altX,sameX,interaction1="Smoking")
SAOM.terms&lt;-includeEffects(SAOM.terms,transTies,inPop)


create.model&lt;-sienaAlgorithmCreate(projname="netmediate",
                                   nsub=5,
                                   n3=2000)


##estimate the SAOM
SAOM_model&lt;-siena07(create.model,
                    data=SAOM.Data,
                    effects=SAOM.terms,
                    verbose=TRUE)


##create node-level data
node_level_data&lt;-data.frame(smoking=s50s[,1], #smoking behavior for DV
                            alcohol=s50a[,1],
                            v_id=rownames(s501), #unique node IDS
                            wave="Wave 1",       #unique time IDS
                            outdegree=rowSums(s501),
                            indegree=colSums(s501),
                            AR1=s501%*%s50s[,1],  #assign network autocorrelation
                            gcc=gtrans(as.network(s501)))

node_level_data&lt;-rbind(node_level_data,data.frame(smoking=s50s[,2],
                                                  alcohol=s50a[,2],
                                                  v_id=rownames(s502),
                                                  wave="Wave 2",
                                                  outdegree=rowSums(s502),
                                                  indegree=colSums(s502),
                                                  AR1=s502%*%s50s[,2],
                                                  gcc=gtrans(as.network(s502))))



node_level_data&lt;-rbind(node_level_data,data.frame(smoking=s50s[,3],
                                                  alcohol=s50a[,3],
                                                  v_id=rownames(s503),
                                                  wave="Wave 3",
                                                  outdegree=rowSums(s503),
                                                  indegree=colSums(s503),
                                                  AR1=s503%*%s50s[,3],
                                                  gcc=gtrans(as.network(s503))))


#recycle the same model for illustrative purposes
node_level_data$net_ID&lt;-"Model 1"
node_level_data&lt;-rbind(node_level_data,node_level_data)
node_level_data$net_ID[151:300]&lt;-"Model 2"

##create unique identifiers for node-panel
  #ID for node-panel-model
node_level_data$unique_id&lt;-paste(node_level_data$v_id,node_level_data$wave,node_level_data$net_ID)
  #ID for panel-model
node_level_data$unique_waves&lt;-paste(node_level_data$wave,node_level_data$net_ID)

#estimate a linear network autocorrelation model with node fixed effects
FE_model&lt;-lm(smoking~alcohol+outdegree+indegree+AR1+gcc+v_id,
              data=node_level_data)



##create user function calculate AR1 process on time varying node attributes
ar_function&lt;-function(x){return(as.sociomatrix(x)%*%(x%v%"Smoking"))}

##estimate AMME
AMME(micro_model=list(SAOM_model,SAOM_model), #provide list of sienaFit objects
     macro_model=FE_model,
     micro_process="reciprocity",
     mediator="indegree",
     macro_function=function(x){degree(x,cmode="indegree")},
     link_id=list(node_level_data$unique_id,node_level_data$unique_id,
                        node_level_data$unique_id,node_level_data$unique_waves),
     object_type="network",
     controls=c("outdegree","AR1","gcc"),
     control_functions=list(function(x){degree(x,cmode="outdegree")},ar_function,gtrans),
     interval=c(0,.1),
     nsim=100,                  #parametric estimation requires more simulations than coefficients
     algorithm="parametric",
     silent=FALSE,
     SAOM_data = list(SAOM.Data,SAOM.Data), #list of siena objects
     SAOM_var=list(list(Smoking=Smoking,Alcohol=Alcohol),#provide var_list
                  list(Smoking=Smoking,Alcohol=Alcohol)))





#################################
# AMME with nested data
################################

####create dyad-level data

library(lme4)
library(btergm)
##use small data to simplify estimation
glm_dat&lt;-edgeprob(model1)
glm_dat$net_id&lt;-"mesa"
glm_dat2&lt;-edgeprob(model2)
glm_dat2$net_id&lt;-"magnolia"
glm_dat&lt;-rbind(glm_dat,glm_dat2[,-c(4)])


##estimate micro model as glm for btoh networks using pooled ERGM data
net_glm&lt;-glm(tie~nodecov.Grade+
                 nodefactor.Race.Hisp+
                 nodefactor.Race.NatAm+
                 nodefactor.Race.Other+
                 nodefactor.Sex.M+
                 nodematch.Race+
                 nodematch.Sex+
                 absdiff.Grade,
               data=glm_dat)


#create macro data
node_level_data&lt;-data.frame(grade=faux.mesa.high%v%"Grade",
                            sex=faux.mesa.high%v%"Sex",
                            degree=degree(faux.mesa.high),
                            betweenness=betweenness(faux.mesa.high),
                            gcc=gtrans(faux.mesa.high),
                            net_id="Mesa")

node_level_data$senior&lt;-0
node_level_data$senior[node_level_data$grade==max(node_level_data$grade)]&lt;-1
node_level_data$v_id&lt;-1:network.size(faux.mesa.high)


node_level_data2&lt;-data.frame(grade=faux.magnolia.high%v%"Grade",
                             sex=faux.magnolia.high%v%"Sex",
                             degree=degree(faux.magnolia.high),
                             betweenness=betweenness(faux.magnolia.high),
                             gcc=gtrans(faux.magnolia.high),
                             net_id="Magnolia")

node_level_data2$senior&lt;-0
node_level_data2$senior[node_level_data$grade==max(node_level_data2$grade)]&lt;-1
node_level_data2$v_id&lt;-206:(network.size(faux.magnolia.high)+205)
node_level_data&lt;-rbind(node_level_data,node_level_data2)


#estimate glm macro model
probit_model&lt;-glm(senior~sex+degree+betweenness+gcc,
                  data=node_level_data,
                  family=binomial(link="probit"))




AMME(micro_model=net_glm,
     macro_model=probit_model,
     micro_process="nodematch.Sex",
     mediator="degree",
     macro_function=degree,
     link_id=list(node_level_data$v_id,node_level_data$v_id,node_level_data$net_id),
     object_type="network",
     controls=c("betweenness","gcc"),
     control_functions=list(betweenness,gtrans),
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE,
     group_id=glm_dat$net_id,
     node_numbers = c(network.size(faux.mesa.high),
                      network.size(faux.magnolia.high)))




###using glmer for micro model
net_glmer&lt;-glmer(tie~nodecov.Grade+
                 nodefactor.Race.Hisp+
                 nodefactor.Race.NatAm+
                 nodefactor.Race.Other+
                 nodefactor.Sex.M+
                 nodematch.Race+
                 nodematch.Sex+
                 absdiff.Grade+
                 (1|net_id),
               data=glm_dat)

probit_glmer&lt;-glm(senior~sex+degree+betweenness+gcc,
                data=node_level_data,
                family=binomial(link="probit"))


AMME(micro_model=net_glm,
     macro_model=probit_glmer,
     micro_process="nodematch.Sex",
     mediator="degree",
     macro_function=degree,
     link_id=list(node_level_data$v_id,node_level_data$v_id,node_level_data$net_id),
     object_type="network",
     controls=c("betweenness","gcc"),
     control_functions=list(betweenness,gtrans),
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE,
     group_id=glm_dat$net_id,
     node_numbers = c(network.size(faux.mesa.high),
                      network.size(faux.magnolia.high)))








</code></pre>


</div>