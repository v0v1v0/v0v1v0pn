<div class="container">

<table style="width: 100%;"><tr>
<td>network.extensions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Dynamically Extended Core Network Functions </h2>

<h3>Description</h3>

<p>Various core functions from the network package, with specialized extensions for handling dynamic data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get.edgeIDs.active(x, v, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    alter = NULL, neighborhood = c("out", "in", "combined"), 
    rule = c("any", "all", "earliest", "latest"), na.omit = TRUE, active.default = TRUE)
get.edges.active(x, v, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    alter = NULL, neighborhood = c("out", "in", "combined"), 
    rule = c("any", "all", "earliest", "latest"), na.omit = TRUE, active.default = TRUE)
get.neighborhood.active(x, v, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    type = c("out", "in", "combined"), rule = c("any", "all", "earliest", "latest"), 
    na.omit = TRUE, active.default = TRUE)

is.adjacent.active(x, vi, vj, onset = NULL, terminus = NULL, length = NULL, at = NULL, 
    rule = c("any", "all", "earliest", "latest"), na.omit = FALSE, active.default = TRUE)

## S3 method for class 'active'
network.dyadcount(x, onset = NULL, terminus = NULL, length = NULL, at = NULL, 
    rule = c("any", "all", "earliest", "latest"),
    na.omit = TRUE, active.default = TRUE,...)
## S3 method for class 'active'
network.edgecount(x, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    rule = c("any", "all", "earliest", "latest"),
    na.omit = TRUE, active.default = TRUE,...)
## S3 method for class 'active'
network.naedgecount(x, onset = NULL, terminus = NULL, length = NULL, at = NULL, 
    rule = c("any", "all", "earliest", "latest"),
    active.default = TRUE,...)
## S3 method for class 'active'
network.size(x, onset = NULL, terminus = NULL, length = NULL, at = NULL, 
    rule = c("any", "all", "earliest", "latest"),
    active.default = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> an object of class <code>network</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p> a required vertex ID. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vi</code></td>
<td>
<p>an optional vertex ID (tail).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vj</code></td>
<td>
<p>an optional vertex ID (head).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onset</code></td>
<td>
<p> an optional start time for the selection interval. This must be  accompanied by one of <code>terminus</code> or <code>length</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminus</code></td>
<td>
<p> an optional end time for the selection interval.  This must be accompanied by one of <code>onset</code> or <code>length</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length</code></td>
<td>
<p> the length of the selection interval. This must be  accompanied by one of <code>onset</code> or <code>terminus</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p> a time point for selecting edges/vertices. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alter</code></td>
<td>
<p> optionally, the ID of another vertex. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighborhood</code></td>
<td>
<p> a text string that indicates whether we are interested in in-edges, out-edges, or both (relative to <code>v</code>).  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> a text string that functions as <code>neighborhood</code>, above, for vertex neighborhoods. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p> a text string for defining “active” for this call:  <code>any</code> (default) to select elements appearing at any time during the specified interval, or <code>all</code> to select only elements active for the entire interval. For these functions, the values of <code>earliest</code> and <code>latest</code> are equivalent to <code>any</code> and are only included for consistency.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.omit</code></td>
<td>
<p> logical; should we omit missing edges? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>active.default</code></td>
<td>
<p> logical; should elements without an activity attribute be regarded as active by default? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>possible additional argumenets</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions are “dynamically extended” versions of their standard network counterparts.  As such, conventional aspects of their behavior can be found on their respective manual pages (see below).  In all cases, the sole difference between the extended and non-extended versions lies in the ability of the user to specify a time point (or interval), such that only vertices and edges active at the indicated time (or during the indicated interval) are employed by the routine.
</p>

<p>For elements (edges and vertices) lacking an activity attribute, the <code>active.default</code> argument determines appropriate treatment.  By default, all such elements are considered active.
</p>


<h3>Value</h3>

<p>The return value matches that of the original function, suitably filtered.
</p>


<h3>Note</h3>

<p> The current temporal implementation of these routines will be slower compared to the non-temporal versions.  Do not use them unless you have to. </p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

<p> Butts, C. T.  (2008).  “network: a Package for Managing Relational Data in R.”  <em>Journal of Statistical Software</em>, 24(2).  <a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a> </p>


<h3>See Also</h3>

 <p><code>network.extract</code>, <code>is.active</code>, <code>get.edgeIDs</code>, <code>get.edges</code>, <code>get.neighborhood</code>, <code>is.adjacent</code>, <code>network.dyadcount</code>, <code>network.edgecount</code>, <code>network.naedgecount</code>, <code>network.size</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
## is.adjacent.active
triangle &lt;- network.initialize(3)    # create a toy network
add.edge(triangle,1,2)               # add an edge between vertices 1 and 2
add.edge(triangle,2,3)               # add a more edges
add.edge(triangle,3,1)
is.adjacent.active(triangle,vi=1,vj=2,onset=2,length=1)

## get.edges.active
net &lt;-network.initialize(5)
net[1,2]&lt;-1;
net[2,3]&lt;-1;
activate.edges(net,onset=1,terminus=Inf,e=1)
activate.edges(net,onset=2,terminus=3,e=2)
get.edges.active(net,v=2,at=1)
get.edges.active(net,v=2,at=1, neighborhood="combined")
get.edges.active(net,v=2,at=2, neighborhood="combined")

## get the ids of the active edges instead (could be multiple incident edges)
get.edgeIDs.active(net,v=2,at=2)

## or get ids of the active nodes in a vertex neighborhood
get.neighborhood.active(net,v=2,at=2)

# returns both edges
get.edges.active(net,v=2,onset=1, terminus=3, neighborhood="combined", rule='any')
# returns only one edge (e=2)
get.edges.active(net,v=2,onset=1, terminus=3, neighborhood="combined", rule='all')

## network.edgecount.active
network.edgecount.active(net, at=1, active.default=FALSE)
network.edgecount.active(net, at=2, active.default=FALSE)
network.edgecount.active(net, at=5, active.default=FALSE)

</code></pre>


</div>