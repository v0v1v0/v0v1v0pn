<div class="container">

<table style="width: 100%;"><tr>
<td>nlmixr2AugPredSolve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Augmented Prediction for nlmixr2 fit</h2>

<h3>Description</h3>

<p>Augmented Prediction for nlmixr2 fit
</p>


<h3>Usage</h3>

<pre><code class="language-R">nlmixr2AugPredSolve(
  fit,
  covsInterpolation = c("locf", "nocb", "linear", "midpoint"),
  minimum = NULL,
  maximum = NULL,
  length.out = 51L,
  ...
)

## S3 method for class 'nlmixr2FitData'
augPred(
  object,
  primary = NULL,
  minimum = NULL,
  maximum = NULL,
  length.out = 51,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>Nlmixr2 fit object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covsInterpolation</code></td>
<td>
<p>specifies the interpolation method for
time-varying covariates. When solving ODEs it often samples
times outside the sampling time specified in <code>events</code>.
When this happens, the time varying covariates are
interpolated.  Currently this can be:
</p>

<ul>
<li> <p><code>"linear"</code> interpolation, which interpolates the covariate
by solving the line between the observed covariates and extrapolating the new
covariate value.
</p>
</li>
<li> <p><code>"locf"</code> – Last observation carried forward (the default).
</p>
</li>
<li> <p><code>"nocb"</code> – Next Observation Carried Backward.  This is the same method
that NONMEM uses.
</p>
</li>
<li> <p><code>"midpoint"</code> Last observation carried forward to midpoint; Next observation
carried backward to midpoint.
</p>
<p>For time-varying covariates where a missing value is present, the
interpolation method will use either "locf" or "nocb" throughout
if they are the type of covariate interpolation that is selected.
</p>
<p>When using the linear or midpoint interpolation, the lower point
in the interpolation will use locf to interpolate missing
covariates and the upper point will use the nocb to interpolate
missing covariates.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minimum</code></td>
<td>
<p>an optional lower limit for the primary
covariate. Defaults to <code>min(primary)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximum</code></td>
<td>
<p>an optional upper limit for the primary
covariate. Defaults to <code>max(primary)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length.out</code></td>
<td>
<p>an optional integer with the number of primary
covariate values at which to evaluate the predictions.  Defaults to
51.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>some methods for the generic may require additional
arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted model object from which predictions can be
extracted, using a <code>predict</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>primary</code></td>
<td>
<p>an optional one-sided formula specifying the primary
covariate to be used to generate the augmented predictions. By
default, if a  covariate can be extracted from the data used to generate
<code>object</code> (using <code>getCovariate</code>), it will be used as
<code>primary</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Stacked data.frame with observations, individual/population predictions.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


</div>