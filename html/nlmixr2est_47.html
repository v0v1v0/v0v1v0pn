<div class="container">

<table style="width: 100%;"><tr>
<td>foceiControl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Control Options for FOCEi</h2>

<h3>Description</h3>

<p>Control Options for FOCEi
</p>


<h3>Usage</h3>

<pre><code class="language-R">foceiControl(
  sigdig = 3,
  ...,
  epsilon = NULL,
  maxInnerIterations = 1000,
  maxOuterIterations = 5000,
  n1qn1nsim = NULL,
  print = 1L,
  printNcol = floor((getOption("width") - 23)/12),
  scaleTo = 1,
  scaleObjective = 0,
  normType = c("rescale2", "mean", "rescale", "std", "len", "constant"),
  scaleType = c("nlmixr2", "norm", "mult", "multAdd"),
  scaleCmax = 1e+05,
  scaleCmin = 1e-05,
  scaleC = NULL,
  scaleC0 = 1e+05,
  derivEps = rep(20 * sqrt(.Machine$double.eps), 2),
  derivMethod = c("switch", "forward", "central"),
  derivSwitchTol = NULL,
  covDerivMethod = c("central", "forward"),
  covMethod = c("r,s", "r", "s", ""),
  hessEps = (.Machine$double.eps)^(1/3),
  hessEpsLlik = (.Machine$double.eps)^(1/3),
  optimHessType = c("central", "forward"),
  optimHessCovType = c("central", "forward"),
  eventType = c("central", "forward"),
  centralDerivEps = rep(20 * sqrt(.Machine$double.eps), 2),
  lbfgsLmm = 7L,
  lbfgsPgtol = 0,
  lbfgsFactr = NULL,
  eigen = TRUE,
  addPosthoc = TRUE,
  diagXform = c("sqrt", "log", "identity"),
  sumProd = FALSE,
  optExpression = TRUE,
  literalFix = TRUE,
  ci = 0.95,
  useColor = crayon::has_color(),
  boundTol = NULL,
  calcTables = TRUE,
  noAbort = TRUE,
  interaction = TRUE,
  cholSEtol = (.Machine$double.eps)^(1/3),
  cholAccept = 0.001,
  resetEtaP = 0.15,
  resetThetaP = 0.05,
  resetThetaFinalP = 0.15,
  diagOmegaBoundUpper = 5,
  diagOmegaBoundLower = 100,
  cholSEOpt = FALSE,
  cholSECov = FALSE,
  fo = FALSE,
  covTryHarder = FALSE,
  outerOpt = c("nlminb", "bobyqa", "lbfgsb3c", "L-BFGS-B", "mma", "lbfgsbLG", "slsqp",
    "Rvmmin"),
  innerOpt = c("n1qn1", "BFGS"),
  rhobeg = 0.2,
  rhoend = NULL,
  npt = NULL,
  rel.tol = NULL,
  x.tol = NULL,
  eval.max = 4000,
  iter.max = 2000,
  abstol = NULL,
  reltol = NULL,
  resetHessianAndEta = FALSE,
  stateTrim = Inf,
  shi21maxOuter = 0L,
  shi21maxInner = 20L,
  shi21maxInnerCov = 20L,
  shi21maxFD = 20L,
  gillK = 10L,
  gillStep = 4,
  gillFtol = 0,
  gillRtol = sqrt(.Machine$double.eps),
  gillKcov = 10L,
  gillKcovLlik = 10L,
  gillStepCovLlik = 4.5,
  gillStepCov = 2,
  gillFtolCov = 0,
  gillFtolCovLlik = 0,
  rmatNorm = TRUE,
  rmatNormLlik = TRUE,
  smatNorm = TRUE,
  smatNormLlik = TRUE,
  covGillF = TRUE,
  optGillF = TRUE,
  covSmall = 1e-05,
  adjLik = TRUE,
  gradTrim = Inf,
  maxOdeRecalc = 5,
  odeRecalcFactor = 10^(0.5),
  gradCalcCentralSmall = 1e-04,
  gradCalcCentralLarge = 10000,
  etaNudge = qnorm(1 - 0.05/2)/sqrt(3),
  etaNudge2 = qnorm(1 - 0.05/2) * sqrt(3/5),
  nRetries = 3,
  seed = 42,
  resetThetaCheckPer = 0.1,
  etaMat = NULL,
  repeatGillMax = 1,
  stickyRecalcN = 4,
  gradProgressOfvTime = 10,
  addProp = c("combined2", "combined1"),
  badSolveObjfAdj = 100,
  compress = TRUE,
  rxControl = NULL,
  sigdigTable = NULL,
  fallbackFD = FALSE,
  smatPer = 0.6,
  sdLowerFact = 0.001,
  zeroGradFirstReset = TRUE,
  zeroGradRunReset = TRUE,
  zeroGradBobyqa = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sigdig</code></td>
<td>
<p>Optimization significant digits. This controls:
</p>

<ul>
<li>
<p> The tolerance of the inner and outer optimization is <code>10^-sigdig</code>
</p>
</li>
<li>
<p> The tolerance of the ODE solvers is
<code>0.5*10^(-sigdig-2)</code>; For the sensitivity equations and
steady-state solutions the default is <code>0.5*10^(-sigdig-1.5)</code>
(sensitivity changes only applicable for liblsoda)
</p>
</li>
<li>
<p> The tolerance of the boundary check is <code>5 * 10 ^ (-sigdig + 1)</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Precision of estimate for n1qn1 optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxInnerIterations</code></td>
<td>
<p>Number of iterations for n1qn1
optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxOuterIterations</code></td>
<td>
<p>Maximum number of L-BFGS-B optimization
for outer problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n1qn1nsim</code></td>
<td>
<p>Number of function evaluations for n1qn1
optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print</code></td>
<td>
<p>Integer representing when the outer step is
printed. When this is 0 or do not print the iterations.  1 is
print every function evaluation (default), 5 is print every 5
evaluations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printNcol</code></td>
<td>
<p>Number of columns to printout before wrapping
parameter estimates/gradient</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleTo</code></td>
<td>
<p>Scale the initial parameter estimate to this value.
By default this is 1.  When zero or below, no scaling is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleObjective</code></td>
<td>
<p>Scale the initial objective function to this
value.  By default this is 0 (meaning do not scale)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normType</code></td>
<td>
<p>This is the type of parameter
normalization/scaling used to get the scaled initial values
for nlmixr2.  These are used with <code>scaleType</code> of.
</p>
<p>With the exception of <code>rescale2</code>, these come
from
<a href="https://en.wikipedia.org/wiki/Feature_scaling">Feature
Scaling</a>. The <code>rescale2</code> The rescaling is the same type
described in the
<a href="http://apmonitor.com/me575/uploads/Main/optimization_book.pdf">OptdesX</a>
software manual.
</p>
<p>In general, all all scaling formula can be described by:
</p>
<p style="text-align: center;"><code class="reqn">v_{scaled}</code>
</p>
<p> = (</p>
<p style="text-align: center;"><code class="reqn">v_{unscaled}-C_{1}</code>
</p>
<p>)/</p>
<p style="text-align: center;"><code class="reqn">C_{2}</code>
</p>

<p>Where
</p>
<p>The other data normalization approaches follow the following formula
</p>
<p style="text-align: center;"><code class="reqn">v_{scaled}</code>
</p>
<p> = (</p>
<p style="text-align: center;"><code class="reqn">v_{unscaled}-C_{1}</code>
</p>
<p>)/</p>
<p style="text-align: center;"><code class="reqn">C_{2}</code>
</p>


<ul>
<li> <p><code>rescale2</code> This scales all parameters from (-1 to 1).
The relative differences between the parameters are preserved
with this approach and the constants are:
</p>
<p style="text-align: center;"><code class="reqn">C_{1}</code>
</p>
<p> = (max(all unscaled values)+min(all unscaled values))/2
</p>
<p style="text-align: center;"><code class="reqn">C_{2}</code>
</p>
<p> = (max(all unscaled values) - min(all unscaled values))/2
</p>
</li>
<li> <p><code>rescale</code> or min-max normalization. This rescales all
parameters from (0 to 1).  As in the <code>rescale2</code> the
relative differences are preserved.  In this approach:
</p>
<p style="text-align: center;"><code class="reqn">C_{1}</code>
</p>
<p> = min(all unscaled values)
</p>
<p style="text-align: center;"><code class="reqn">C_{2}</code>
</p>
<p> = max(all unscaled values) - min(all unscaled values)
</p>
</li>
<li> <p><code>mean</code> or mean normalization.  This rescales to center
the parameters around the mean but the parameters are from 0
to 1.  In this approach:
</p>
<p style="text-align: center;"><code class="reqn">C_{1}</code>
</p>
<p> = mean(all unscaled values)
</p>
<p style="text-align: center;"><code class="reqn">C_{2}</code>
</p>
<p> = max(all unscaled values) - min(all unscaled values)
</p>
</li>
<li> <p><code>std</code> or standardization.  This standardizes by the mean
and standard deviation.  In this approach:
</p>
<p style="text-align: center;"><code class="reqn">C_{1}</code>
</p>
<p> = mean(all unscaled values)
</p>
<p style="text-align: center;"><code class="reqn">C_{2}</code>
</p>
<p> = sd(all unscaled values)
</p>
</li>
<li> <p><code>len</code> or unit length scaling.  This scales the
parameters to the unit length.  For this approach we use the Euclidean length, that
is:
</p>
<p style="text-align: center;"><code class="reqn">C_{1}</code>
</p>
<p> = 0
</p>
<p style="text-align: center;"><code class="reqn">C_{2}</code>
</p>
<p> = </p>
<p style="text-align: center;"><code class="reqn">\sqrt(v_1^2 + v_2^2 + \cdots + v_n^2)</code>
</p>

</li>
<li> <p><code>constant</code> which does not perform data normalization. That is
</p>
<p style="text-align: center;"><code class="reqn">C_{1}</code>
</p>
<p> = 0
</p>
<p style="text-align: center;"><code class="reqn">C_{2}</code>
</p>
<p> = 1
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleType</code></td>
<td>
<p>The scaling scheme for nlmixr2.  The supported types are:
</p>

<ul>
<li> <p><code>nlmixr2</code>  In this approach the scaling is performed by the following equation:
</p>
<p style="text-align: center;"><code class="reqn">v_{scaled}</code>
</p>
<p> = (</p>
<p style="text-align: center;"><code class="reqn">v_{current} - v_{init}</code>
</p>
<p>)*scaleC[i] + scaleTo
</p>
<p>The <code>scaleTo</code> parameter is specified by the <code>normType</code>,
and the scales are specified by <code>scaleC</code>.
</p>
</li>
<li> <p><code>norm</code> This approach uses the simple scaling provided
by the <code>normType</code> argument.
</p>
</li>
<li> <p><code>mult</code> This approach does not use the data
normalization provided by <code>normType</code>, but rather uses
multiplicative scaling to a constant provided by the <code>scaleTo</code>
argument.
</p>
<p>In this case:
</p>
<p style="text-align: center;"><code class="reqn">v_{scaled}</code>
</p>
<p> = </p>
<p style="text-align: center;"><code class="reqn">v_{current}</code>
</p>
<p>/</p>
<p style="text-align: center;"><code class="reqn">v_{init}</code>
</p>
<p>*scaleTo
</p>
</li>
<li> <p><code>multAdd</code> This approach changes the scaling based on
the parameter being specified.  If a parameter is defined in an
exponential block (ie exp(theta)), then it is scaled on a
linearly, that is:
</p>
<p style="text-align: center;"><code class="reqn">v_{scaled}</code>
</p>
<p> = (</p>
<p style="text-align: center;"><code class="reqn">v_{current}-v_{init}</code>
</p>
<p>) + scaleTo
</p>
<p>Otherwise the parameter is scaled multiplicatively.
</p>
<p style="text-align: center;"><code class="reqn">v_{scaled}</code>
</p>
<p> = </p>
<p style="text-align: center;"><code class="reqn">v_{current}</code>
</p>
<p>/</p>
<p style="text-align: center;"><code class="reqn">v_{init}</code>
</p>
<p>*scaleTo
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleCmax</code></td>
<td>
<p>Maximum value of the scaleC to prevent overflow.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleCmin</code></td>
<td>
<p>Minimum value of the scaleC to prevent underflow.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleC</code></td>
<td>
<p>The scaling constant used with
<code>scaleType=nlmixr2</code>.  When not specified, it is based on
the type of parameter that is estimated.  The idea is to keep
the derivatives similar on a log scale to have similar
gradient sizes.  Hence parameters like log(exp(theta)) would
have a scaling factor of 1 and log(theta) would have a scaling
factor of ini_value (to scale by 1/value; ie
d/dt(log(ini_value)) = 1/ini_value or scaleC=ini_value)
</p>

<ul>
<li>
<p> For parameters in an exponential (ie exp(theta)) or
parameters specifying powers, boxCox or yeoJohnson
transformations , this is 1.
</p>
</li>
<li>
<p> For additive, proportional, lognormal error structures,
these are given by 0.5*abs(initial_estimate)
</p>
</li>
<li>
<p> Factorials are scaled by abs(1/digamma(initial_estimate+1))
</p>
</li>
<li>
<p> parameters in a log scale (ie log(theta)) are transformed
by log(abs(initial_estimate))*abs(initial_estimate)
</p>
</li>
</ul>
<p>These parameter scaling coefficients are chose to try to keep
similar slopes among parameters.  That is they all follow the
slopes approximately on a log-scale.
</p>
<p>While these are chosen in a logical manner, they may not always
apply.  You can specify each parameters scaling factor by this
parameter if you wish.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleC0</code></td>
<td>
<p>Number to adjust the scaling factor by if the initial
gradient is zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>derivEps</code></td>
<td>
<p>Forward difference tolerances, which is a
vector of relative difference and absolute difference.  The
central/forward difference step size h is calculated as:
</p>
<p><code>h = abs(x)*derivEps[1] + derivEps[2]</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>derivMethod</code></td>
<td>
<p>indicates the method for calculating
derivatives of the outer problem.  Currently supports
"switch", "central" and "forward" difference methods.  Switch
starts with forward differences.  This will switch to central
differences when abs(delta(OFV)) &lt;= derivSwitchTol and switch
back to forward differences when abs(delta(OFV)) &gt;
derivSwitchTol.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>derivSwitchTol</code></td>
<td>
<p>The tolerance to switch forward to central
differences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covDerivMethod</code></td>
<td>
<p>indicates the method for calculating the
derivatives while calculating the covariance components
(Hessian and S).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covMethod</code></td>
<td>
<p>Method for calculating covariance.  In this
discussion, R is the Hessian matrix of the objective
function. The S matrix is the sum of individual
gradient cross-product (evaluated at the individual empirical
Bayes estimates).
</p>

<ul>
<li>
<p> "<code>r,s</code>" Uses the sandwich matrix to calculate the
covariance, that is: <code>solve(R) %*% S %*% solve(R)</code>
</p>
</li>
<li>
<p> "<code>r</code>" Uses the Hessian matrix to calculate the
covariance as <code>2 %*% solve(R)</code>
</p>
</li>
<li>
<p> "<code>s</code>" Uses the cross-product matrix to calculate the
covariance as <code>4 %*% solve(S)</code>
</p>
</li>
<li>
<p> "" Does not calculate the covariance step.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessEps</code></td>
<td>
<p>is a double value representing the epsilon for the
Hessian calculation. This is used for the R matrix calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessEpsLlik</code></td>
<td>
<p>is a double value representing the epsilon for
the Hessian calculation when doing focei generalized
log-likelihood estimation.  This is used for the R matrix
calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimHessType</code></td>
<td>
<p>The hessian type for when calculating the
individual hessian by numeric differences (in generalized
log-likelihood estimation).  The options are "central", and
"forward".  The central differences is what R's 'optimHess()'
uses and is the default for this method. (Though the "forward" is
faster and still reasonable for most cases).  The Shi21 cannot be
changed for the Gill83 algorithm with the optimHess in a
generalized likelihood problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimHessCovType</code></td>
<td>
<p>The hessian type for when calculating the
individual hessian by numeric differences (in generalized
log-likelihood estimation).  The options are "central", and
"forward".  The central differences is what R's 'optimHess()'
uses.  While this takes longer in optimization, it is more
accurate, so for calculating the covariance and final likelihood,
the central differences are used. This also uses the modified
Shi21 method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eventType</code></td>
<td>
<p>Event gradient type for dosing events; Can be
"central" or "forward"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centralDerivEps</code></td>
<td>
<p>Central difference tolerances.  This is a
numeric vector of relative difference and absolute difference.
The central/forward difference step size h is calculated as:
</p>
<p><code>h = abs(x)*derivEps[1] + derivEps[2]</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbfgsLmm</code></td>
<td>
<p>An integer giving the number of BFGS updates
retained in the "L-BFGS-B" method, It defaults to 7.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbfgsPgtol</code></td>
<td>
<p>is a double precision variable.
</p>
<p>On entry pgtol &gt;= 0 is specified by the user.  The iteration
will stop when:
</p>
<p><code>max(\| proj g_i \| i = 1, ..., n) &lt;= lbfgsPgtol</code>
</p>
<p>where pg_i is the ith component of the projected gradient.
</p>
<p>On exit pgtol is unchanged.  This defaults to zero, when the
check is suppressed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbfgsFactr</code></td>
<td>
<p>Controls the convergence of the "L-BFGS-B"
method.  Convergence occurs when the reduction in the
objective is within this factor of the machine
tolerance. Default is 1e10, which gives a tolerance of about
<code>2e-6</code>, approximately 4 sigdigs.  You can check your
exact tolerance by multiplying this value by
<code>.Machine$double.eps</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigen</code></td>
<td>
<p>A boolean indicating if eigenvectors are calculated
to include a condition number calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addPosthoc</code></td>
<td>
<p>Boolean indicating if posthoc parameters are
added to the table output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagXform</code></td>
<td>
<p>This is the transformation used on the diagonal
of the <code>chol(solve(omega))</code>. This matrix and values are the
parameters estimated in FOCEi. The possibilities are:
</p>

<ul>
<li> <p><code>sqrt</code> Estimates the sqrt of the diagonal elements of <code>chol(solve(omega))</code>.  This is the default method.
</p>
</li>
<li> <p><code>log</code> Estimates the log of the diagonal elements of <code>chol(solve(omega))</code>
</p>
</li>
<li> <p><code>identity</code> Estimates the diagonal elements without any transformations
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sumProd</code></td>
<td>
<p>Is a boolean indicating if the model should change
multiplication to high precision multiplication and sums to
high precision sums using the PreciseSums package.  By default
this is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optExpression</code></td>
<td>
<p>Optimize the rxode2 expression to speed up
calculation. By default this is turned on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>literalFix</code></td>
<td>
<p>boolean, substitute fixed population values as
literals and re-adjust ui and parameter estimates after
optimization; Default is 'TRUE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>Confidence level for some tables.  By default this is
0.95 or 95% confidence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useColor</code></td>
<td>
<p>Boolean indicating if focei can use ASCII color codes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundTol</code></td>
<td>
<p>Tolerance for boundary issues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calcTables</code></td>
<td>
<p>This boolean is to determine if the foceiFit
will calculate tables. By default this is <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noAbort</code></td>
<td>
<p>Boolean to indicate if you should abort the FOCEi
evaluation if it runs into troubles.  (default TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction</code></td>
<td>
<p>Boolean indicate FOCEi should be used (TRUE)
instead of FOCE (FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cholSEtol</code></td>
<td>
<p>tolerance for Generalized Cholesky
Decomposition.  Defaults to suggested (.Machine$double.eps)^(1/3)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cholAccept</code></td>
<td>
<p>Tolerance to accept a Generalized Cholesky
Decomposition for a R or S matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resetEtaP</code></td>
<td>
<p>represents the p-value for reseting the
individual ETA to 0 during optimization (instead of the saved
value).  The two test statistics used in the z-test are either
chol(omega^-1) %*% eta or eta/sd(allEtas).  A p-value of 0
indicates the ETAs never reset.  A p-value of 1 indicates the
ETAs always reset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resetThetaP</code></td>
<td>
<p>represents the p-value for reseting the
population mu-referenced THETA parameters based on ETA drift
during optimization, and resetting the optimization.  A
p-value of 0 indicates the THETAs never reset.  A p-value of 1
indicates the THETAs always reset and is not allowed.  The
theta reset is checked at the beginning and when nearing a
local minima.  The percent change in objective function where
a theta reset check is initiated is controlled in
<code>resetThetaCheckPer</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resetThetaFinalP</code></td>
<td>
<p>represents the p-value for reseting the
population mu-referenced THETA parameters based on ETA drift
during optimization, and resetting the optimization one final time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagOmegaBoundUpper</code></td>
<td>
<p>This represents the upper bound of the
diagonal omega matrix.  The upper bound is given by
diag(omega)*diagOmegaBoundUpper.  If
<code>diagOmegaBoundUpper</code> is 1, there is no upper bound on
Omega.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagOmegaBoundLower</code></td>
<td>
<p>This represents the lower bound of the
diagonal omega matrix.  The lower bound is given by
diag(omega)/diagOmegaBoundUpper.  If
<code>diagOmegaBoundLower</code> is 1, there is no lower bound on
Omega.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cholSEOpt</code></td>
<td>
<p>Boolean indicating if the generalized Cholesky
should be used while optimizing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cholSECov</code></td>
<td>
<p>Boolean indicating if the generalized Cholesky
should be used while calculating the Covariance Matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fo</code></td>
<td>
<p>is a boolean indicating if this is a FO approximation routine.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covTryHarder</code></td>
<td>
<p>If the R matrix is non-positive definite and
cannot be corrected to be non-positive definite try estimating
the Hessian on the unscaled parameter space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outerOpt</code></td>
<td>
<p>optimization method for the outer problem</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>innerOpt</code></td>
<td>
<p>optimization method for the inner problem (not
implemented yet.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhobeg</code></td>
<td>
<p>Beginning change in parameters for bobyqa algorithm
(trust region).  By default this is 0.2 or 20
parameters when the parameters are scaled to 1. rhobeg and
rhoend must be set to the initial and final values of a trust
region radius, so both must be positive with 0 &lt; rhoend &lt;
rhobeg. Typically rhobeg should be about one tenth of the
greatest expected change to a variable.  Note also that
smallest difference abs(upper-lower) should be greater than or
equal to rhobeg*2. If this is not the case then rhobeg will be
adjusted. (bobyqa)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhoend</code></td>
<td>
<p>The smallest value of the trust region radius that
is allowed. If not defined, then 10^(-sigdig-1) will be used. (bobyqa)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npt</code></td>
<td>
<p>The number of points used to approximate the objective
function via a quadratic approximation for bobyqa. The value
of npt must be in the interval [n+2,(n+1)(n+2)/2] where n is
the number of parameters in par. Choices that exceed 2*n+1 are
not recommended. If not defined, it will be set to 2*n + 1. (bobyqa)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel.tol</code></td>
<td>
<p>Relative tolerance before nlminb stops (nlmimb).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.tol</code></td>
<td>
<p>X tolerance for nlmixr2 optimizer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eval.max</code></td>
<td>
<p>Number of maximum evaluations of the objective function (nlmimb)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>
<p>Maximum number of iterations allowed (nlmimb)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abstol</code></td>
<td>
<p>Absolute tolerance for nlmixr2 optimizer (BFGS)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>tolerance for nlmixr2 (BFGS)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resetHessianAndEta</code></td>
<td>
<p>is a boolean representing if the
individual Hessian is reset when ETAs are reset using the
option <code>resetEtaP</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stateTrim</code></td>
<td>
<p>Trim state amounts/concentrations to this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shi21maxOuter</code></td>
<td>
<p>The maximum number of steps for the
optimization of the forward-difference step size.  When not zero,
use this instead of Gill differences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shi21maxInner</code></td>
<td>
<p>The maximum number of steps for the
optimization of the individual Hessian matrices in the
generalized likelihood problem. When 0, un-optimized finite differences
are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shi21maxInnerCov</code></td>
<td>
<p>The maximum number of steps for the
optimization of the individual Hessian matrices in the
generalized likelihood problem for the covariance step. When 0,
un-optimized finite differences are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shi21maxFD</code></td>
<td>
<p>The maximum number of steps for the optimization
of the forward difference step size when using dosing events (lag
time, modeled duration/rate and bioavailability)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gillK</code></td>
<td>
<p>The total number of possible steps to determine the
optimal forward/central difference step size per parameter (by
the Gill 1983 method).  If 0, no optimal step size is
determined.  Otherwise this is the optimal step size
determined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gillStep</code></td>
<td>
<p>When looking for the optimal forward difference
step size, this is This is the step size to increase the
initial estimate by.  So each iteration the new step size =
(prior step size)*gillStep</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gillFtol</code></td>
<td>
<p>The gillFtol is the gradient error tolerance that
is acceptable before issuing a warning/error about the gradient estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gillRtol</code></td>
<td>
<p>The relative tolerance used for Gill 1983
determination of optimal step size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gillKcov</code></td>
<td>
<p>The total number of possible steps to determine
the optimal forward/central difference step size per parameter
(by the Gill 1983 method) during the covariance step.  If 0,
no optimal step size is determined.  Otherwise this is the
optimal step size determined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gillKcovLlik</code></td>
<td>
<p>The total number of possible steps to determine
the optimal forward/central difference step per parameter when
using the generalized focei log-likelihood method (by the Gill
1986 method).  If 0, no optimal step size is
determined. Otherwise this is the optimal step size is determined</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gillStepCovLlik</code></td>
<td>
<p>Same as above but during generalized focei
log-likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gillStepCov</code></td>
<td>
<p>When looking for the optimal forward difference
step size, this is This is the step size to increase the
initial estimate by.  So each iteration during the covariance
step is equal to the new step size = (prior step size)*gillStepCov</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gillFtolCov</code></td>
<td>
<p>The gillFtol is the gradient error tolerance
that is acceptable before issuing a warning/error about the
gradient estimates during the covariance step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gillFtolCovLlik</code></td>
<td>
<p>Same as above but applied during generalized
log-likelihood estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmatNorm</code></td>
<td>
<p>A parameter to normalize gradient step size by the
parameter value during the calculation of the R matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmatNormLlik</code></td>
<td>
<p>A parameter to normalize gradient step size by
the parameter value during the calculation of the R matrix if you
are using generalized log-likelihood Hessian matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smatNorm</code></td>
<td>
<p>A parameter to normalize gradient step size by the
parameter value during the calculation of the S matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smatNormLlik</code></td>
<td>
<p>A parameter to normalize gradient step size by
the parameter value during the calculation of the S matrix if you
are using the generalized log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covGillF</code></td>
<td>
<p>Use the Gill calculated optimal Forward difference
step size for the instead of the central difference step size
during the central difference gradient calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optGillF</code></td>
<td>
<p>Use the Gill calculated optimal Forward difference
step size for the instead of the central difference step size
during the central differences for optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covSmall</code></td>
<td>
<p>The covSmall is the small number to compare
covariance numbers before rejecting an estimate of the
covariance as the final estimate (when comparing sandwich vs
R/S matrix estimates of the covariance).  This number controls
how small the variance is before the covariance matrix is
rejected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjLik</code></td>
<td>
<p>In nlmixr2, the objective function matches NONMEM's
objective function, which removes a 2*pi constant from the
likelihood calculation. If this is TRUE, the likelihood
function is adjusted by this 2*pi factor.  When adjusted this
number more closely matches the likelihood approximations of
nlme, and SAS approximations.  Regardless of if this is turned
on or off the objective function matches NONMEM's objective
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradTrim</code></td>
<td>
<p>The parameter to adjust the gradient to if the
|gradient| is very large.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxOdeRecalc</code></td>
<td>
<p>Maximum number of times to reduce the ODE
tolerances and try to resolve the system if there was a bad
ODE solve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>odeRecalcFactor</code></td>
<td>
<p>The ODE recalculation factor when ODE
solving goes bad, this is the factor the rtol/atol is reduced</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradCalcCentralSmall</code></td>
<td>
<p>A small number that represents the value
where |grad| &lt; gradCalcCentralSmall where forward differences
switch to central differences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradCalcCentralLarge</code></td>
<td>
<p>A large number that represents the value
where |grad| &gt; gradCalcCentralLarge where forward differences
switch to central differences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etaNudge</code></td>
<td>
<p>By default initial ETA estimates start at zero;
Sometimes this doesn't optimize appropriately.  If this value is
non-zero, when the n1qn1 optimization didn't perform
appropriately, reset the Hessian, and nudge the ETA up by this
value; If the ETA still doesn't move, nudge the ETA down by this
value. By default this value is qnorm(1-0.05/2)*1/sqrt(3), the
first of the Gauss Quadrature numbers times by the 0.95% normal
region. If this is not successful try the second eta nudge
number (below).  If +-etaNudge2 is not successful, then assign
to zero and do not optimize any longer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etaNudge2</code></td>
<td>
<p>This is the second eta nudge.  By default it is
qnorm(1-0.05/2)*sqrt(3/5), which is the n=3 quadrature point
(excluding zero) times by the 0.95% normal region</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nRetries</code></td>
<td>
<p>If FOCEi doesn't fit with the current parameter
estimates, randomly sample new parameter estimates and restart
the problem.  This is similar to 'PsN' resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>an object specifying if and how the random number
generator should be initialized</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resetThetaCheckPer</code></td>
<td>
<p>represents objective function
% percentage below which resetThetaP is checked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etaMat</code></td>
<td>
<p>Eta matrix for initial estimates or final estimates
of the ETAs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeatGillMax</code></td>
<td>
<p>If the tolerances were reduced when
calculating the initial Gill differences, the Gill difference
is repeated up to a maximum number of times defined by this
parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stickyRecalcN</code></td>
<td>
<p>The number of bad ODE solves before reducing
the atol/rtol for the rest of the problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradProgressOfvTime</code></td>
<td>
<p>This is the time for a single objective
function evaluation (in seconds) to start progress bars on gradient evaluations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addProp</code></td>
<td>
<p>specifies the type of additive plus proportional
errors, the one where standard deviations add (combined1) or the
type where the variances add (combined2).
</p>
<p>The combined1 error type can be described by the following equation:
</p>
<p style="text-align: center;"><code class="reqn">y = f + (a + b\times f^c) \times \varepsilon</code>
</p>

<p>The combined2 error model can be described by the following equation:
</p>
<p style="text-align: center;"><code class="reqn">y = f + \sqrt{a^2 + b^2\times f^{2\times c}} \times \varepsilon</code>
</p>

<p>Where:
</p>
<p>- y represents the observed value
</p>
<p>- f represents the predicted value
</p>
<p>- a  is the additive standard deviation
</p>
<p>- b is the proportional/power standard deviation
</p>
<p>- c is the power exponent (in the proportional case c=1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>badSolveObjfAdj</code></td>
<td>
<p>The objective function adjustment when the
ODE system cannot be solved.  It is based on each individual bad
solve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compress</code></td>
<td>
<p>Should the object have compressed items</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rxControl</code></td>
<td>
<p>'rxode2' ODE solving options during fitting, created with 'rxControl()'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigdigTable</code></td>
<td>
<p>Significant digits in the final output table.
If not specified, then it matches the significant digits in the
'sigdig' optimization algorithm.  If 'sigdig' is NULL, use 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fallbackFD</code></td>
<td>
<p>Fallback to the finite differences if the
sensitivity equations do not solve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smatPer</code></td>
<td>
<p>A percentage representing the number of failed
parameter gradients for each individual (which are replaced with
the overall gradient for the parameter) out of the total number
of gradients parameters (ie 'ntheta*nsub') before the S matrix is
considered to be a bad matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdLowerFact</code></td>
<td>
<p>A factor for multiplying the estimate by when
the lower estimate is zero and the error is known to represent a
standard deviation of a parameter (like add.sd, prop.sd, pow.sd,
lnorm.sd, etc).  When zero, no factor is applied.  If your
initial estimate is 0.15 and your lower bound is zero, then the
lower bound would be assumed to be 0.00015.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeroGradFirstReset</code></td>
<td>
<p>boolean, when 'TRUE' if the first
gradient is zero, reset the zero gradient to
'sqrt(.Machine$double.eps)' to get past the bad initial estimate,
otherwise error (and possibly reset), when 'FALSE' error when the
first gradient is zero.  When 'NA' on the last reset, have the
zero gradient ignored, otherwise error and look for another
value.  Default is 'TRUE'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeroGradRunReset</code></td>
<td>
<p>boolean, when 'TRUE' if a gradient is zero,
reset the zero gradient to 'sqrt(.Machine$double.eps)' to get
past the bad estimate while running.  Otherwise error (and
possibly reset). Default is 'TRUE'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeroGradBobyqa</code></td>
<td>
<p>boolean, when 'TRUE' if a gradient is zero,
the reset will change the method to the gradient free bobyqa
method. When 'NA', the zero gradient will change to bobyqa only
when the first gradient is zero.  Default is 'TRUE'</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note this uses the R's L-BFGS-B in <code>optim</code> for the
outer problem and the BFGS <code>n1qn1</code> with that
allows restoring the prior individual Hessian (for faster
optimization speed).
</p>
<p>However the inner problem is not scaled.  Since most eta estimates
start near zero, scaling for these parameters do not make sense.
</p>
<p>This process of scaling can fix some ill conditioning for the
unscaled problem.  The covariance step is performed on the
unscaled problem, so the condition number of that matrix may not
be reflective of the scaled problem's condition-number.
</p>


<h3>Value</h3>

<p>The control object that changes the options for the FOCEi
family of estimation methods
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>References</h3>

<p>Gill, P.E., Murray, W., Saunders, M.A., &amp; Wright,
M.H. (1983). Computing Forward-Difference Intervals for Numerical
Optimization. Siam Journal on Scientific and Statistical Computing,
4, 310-321.
</p>
<p>Shi, H.M., Xie, Y., Xuan, M.Q., &amp; Nocedal, J. (2021). Adaptive
Finite-Difference Interval Estimation for Noisy Derivative-Free
Optimization.
</p>


<h3>See Also</h3>

<p><code>optim</code>
</p>
<p><code>n1qn1</code>
</p>
<p><code>rxSolve</code>
</p>
<p>Other Estimation control: 
<code>nlmixr2NlmeControl()</code>,
<code>saemControl()</code>
</p>


</div>