<div class="container">

<table style="width: 100%;"><tr>
<td>nlmixr2NlmeControl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Control Values for nlme Fit with extra options for nlmixr</h2>

<h3>Description</h3>

<p>The values supplied in the function call replace the defaults and
a list with all possible arguments is returned.  The returned list
is used as the ‘control’ argument to the ‘nlme’ function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nlmixr2NlmeControl(
  maxIter = 100,
  pnlsMaxIter = 100,
  msMaxIter = 100,
  minScale = 0.001,
  tolerance = 1e-05,
  niterEM = 25,
  pnlsTol = 0.001,
  msTol = 1e-06,
  returnObject = FALSE,
  msVerbose = FALSE,
  msWarnNoConv = TRUE,
  gradHess = TRUE,
  apVar = TRUE,
  .relStep = .Machine$double.eps^(1/3),
  minAbsParApVar = 0.05,
  opt = c("nlminb", "nlm"),
  natural = TRUE,
  sigma = NULL,
  optExpression = TRUE,
  literalFix = TRUE,
  sumProd = FALSE,
  rxControl = NULL,
  method = c("ML", "REML"),
  random = NULL,
  fixed = NULL,
  weights = NULL,
  verbose = TRUE,
  returnNlme = FALSE,
  addProp = c("combined2", "combined1"),
  calcTables = TRUE,
  compress = TRUE,
  adjObf = TRUE,
  ci = 0.95,
  sigdig = 4,
  sigdigTable = NULL,
  muRefCovAlg = TRUE,
  ...
)

nlmeControl(
  maxIter = 100,
  pnlsMaxIter = 100,
  msMaxIter = 100,
  minScale = 0.001,
  tolerance = 1e-05,
  niterEM = 25,
  pnlsTol = 0.001,
  msTol = 1e-06,
  returnObject = FALSE,
  msVerbose = FALSE,
  msWarnNoConv = TRUE,
  gradHess = TRUE,
  apVar = TRUE,
  .relStep = .Machine$double.eps^(1/3),
  minAbsParApVar = 0.05,
  opt = c("nlminb", "nlm"),
  natural = TRUE,
  sigma = NULL,
  optExpression = TRUE,
  literalFix = TRUE,
  sumProd = FALSE,
  rxControl = NULL,
  method = c("ML", "REML"),
  random = NULL,
  fixed = NULL,
  weights = NULL,
  verbose = TRUE,
  returnNlme = FALSE,
  addProp = c("combined2", "combined1"),
  calcTables = TRUE,
  compress = TRUE,
  adjObf = TRUE,
  ci = 0.95,
  sigdig = 4,
  sigdigTable = NULL,
  muRefCovAlg = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>maximum number of iterations for the <code>nlme</code>
optimization algorithm.  Default is 50.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pnlsMaxIter</code></td>
<td>
<p>maximum number of iterations
for the <code>PNLS</code> optimization step inside the <code>nlme</code>
optimization.  Default is 7.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msMaxIter</code></td>
<td>
<p>maximum number of iterations for <code>nlminb</code>
(<code>iter.max</code>) or the <code>nlm</code> (<code>iterlim</code>, from the
10-th step) optimization step inside the <code>nlme</code>
optimization.  Default is 50 (which may be too small for e.g. for
overparametrized cases).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minScale</code></td>
<td>
<p>minimum factor by which to shrink the default step size
in an attempt to decrease the sum of squares in the <code>PNLS</code> step.
Default <code>0.001</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>tolerance for the convergence criterion in the
<code>nlme</code> algorithm.  Default is <code>1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niterEM</code></td>
<td>
<p>number of iterations for the EM algorithm used to refine
the initial estimates of the random effects variance-covariance
coefficients.  Default is 25.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pnlsTol</code></td>
<td>
<p>tolerance for the convergence criterion in <code>PNLS</code>
step.  Default is <code>1e-3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msTol</code></td>
<td>
<p>tolerance for the convergence criterion in <code>nlm</code>,
passed as the <code>gradtol</code> argument to the function (see
documentation on <code>nlm</code>).  Default is <code>1e-7</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnObject</code></td>
<td>
<p>a logical value indicating whether the fitted
object should be returned when the maximum number of iterations is
reached without convergence of the algorithm.  Default is
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msVerbose</code></td>
<td>
<p>a logical value passed as the <code>trace</code> to
<code>nlminb(.., control= list(trace = *, ..))</code> or
as argument <code>print.level</code> to <code>nlm()</code>.  Default is
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msWarnNoConv</code></td>
<td>
<p>logical indicating if a <code>warning</code>
should be signalled whenever the minimization (by <code>opt</code>) in the
LME step does not converge; defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradHess</code></td>
<td>
<p>a logical value indicating whether numerical gradient
vectors and Hessian matrices of the log-likelihood function should
be used in the <code>nlm</code> optimization. This option is only available
when the correlation structure (<code>corStruct</code>) and the variance
function structure (<code>varFunc</code>) have no "varying" parameters and
the <code>pdMat</code> classes used in the random effects structure are
<code>pdSymm</code> (general positive-definite), <code>pdDiag</code> (diagonal),
<code>pdIdent</code> (multiple of the identity),  or
<code>pdCompSymm</code> (compound symmetry).  Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>apVar</code></td>
<td>
<p>a logical value indicating whether the approximate
covariance matrix of the variance-covariance parameters should be
calculated.  Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.relStep</code></td>
<td>
<p>relative step for numerical derivatives
calculations.  Default is <code>.Machine$double.eps^(1/3)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minAbsParApVar</code></td>
<td>
<p>numeric value - minimum absolute parameter value
in the approximate variance calculation.  The default is <code>0.05</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt</code></td>
<td>
<p>the optimizer to be used, either <code>"nlminb"</code> (the
default) or <code>"nlm"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>natural</code></td>
<td>
<p>a logical value indicating whether the <code>pdNatural</code>
parametrization should be used for general positive-definite matrices
(<code>pdSymm</code>) in <code>reStruct</code>, when the approximate covariance
matrix of the estimators is calculated.  Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>optionally a positive number to fix the residual error at.
If <code>NULL</code>, as by default, or <code>0</code>, sigma is estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optExpression</code></td>
<td>
<p>Optimize the rxode2 expression to speed up
calculation. By default this is turned on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>literalFix</code></td>
<td>
<p>boolean, substitute fixed population values as
literals and re-adjust ui and parameter estimates after
optimization; Default is 'TRUE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sumProd</code></td>
<td>
<p>Is a boolean indicating if the model should change
multiplication to high precision multiplication and sums to
high precision sums using the PreciseSums package.  By default
this is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rxControl</code></td>
<td>
<p>'rxode2' ODE solving options during fitting, created with 'rxControl()'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string.  If <code>"REML"</code> the model is fit by
maximizing the restricted log-likelihood.  If <code>"ML"</code> the
log-likelihood is maximized.  Defaults to <code>"ML"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>optionally, any of the following: (i) a two-sided formula
of the form <code>r1+...+rn~x1+...+xm | g1/.../gQ</code>, with
<code>r1,...,rn</code> naming parameters included on the right
hand side of <code>model</code>, <code>x1+...+xm</code> specifying the
random-effects model for
these parameters and <code>g1/.../gQ</code> the grouping structure
(<code>Q</code> may be equal to 1, in which case no <code>/</code> is
required). The random effects formula will be repeated
for all levels of grouping, in the case of multiple levels of
grouping; (ii) a two-sided formula of the form
<code>r1+...+rn~x1+..+xm</code>, a list of two-sided formulas of the form
<code>r1~x1+...+xm</code>, with possibly different random-effects models
for different parameters, a <code>pdMat</code> object with a two-sided
formula, or list of two-sided formulas (i.e. a non-<code>NULL</code> value for
<code>formula(random)</code>), or a list of pdMat objects with two-sided
formulas, or lists of two-sided formulas. In this case, the grouping
structure formula will be given in <code>groups</code>, or derived from the
data used to fit the nonlinear mixed-effects model, which should
inherit from class  <code>groupedData</code>,; (iii) a named list
of formulas, lists of formulas, or <code>pdMat</code> objects as in (ii),
with the grouping factors as names. The order of nesting will be
assumed the same as the order of the order of the elements in the
list; (iv) an <code>reStruct</code> object. See the documentation on
<code>pdClasses</code> for a description of the available <code>pdMat</code>
classes. Defaults to <code>fixed</code>,
resulting in all fixed effects having also random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>a two-sided linear formula of the form
<code>f1+...+fn~x1+...+xm</code>, or a list of two-sided formulas of the form
<code>f1~x1+...+xm</code>, with possibly different models for different
parameters. The <code>f1,...,fn</code> are the names of parameters included on
the right hand side of <code>model</code> and the <code>x1+...+xm</code>
expressions define linear models for these parameters (when the left
hand side of the formula contains several parameters, they all are
assumed to follow the same linear model, described by the right hand
side expression).
A <code>1</code> on the right hand side of the formula(s) indicates a single
fixed effects for the corresponding parameter(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional <code>varFunc</code> object or one-sided formula
describing the within-group heteroscedasticity structure. If given as
a formula, it is used as the argument to <code>varFixed</code>,
corresponding to fixed variance weights. See the documentation on
<code>varClasses</code> for a description of the available <code>varFunc</code>
classes. Defaults to <code>NULL</code>, corresponding to homoscedastic
within-group errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> information on
the evolution of the iterative algorithm is printed. Default is
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnNlme</code></td>
<td>
<p>Returns the nlme object instead of the nlmixr
object (by default FALSE).  If any of the nlme specific options
of 'random', 'fixed', 'sens', the nlme object is returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addProp</code></td>
<td>
<p>specifies the type of additive plus proportional
errors, the one where standard deviations add (combined1) or the
type where the variances add (combined2).
</p>
<p>The combined1 error type can be described by the following equation:
</p>
<p style="text-align: center;"><code class="reqn">y = f + (a + b\times f^c) \times \varepsilon</code>
</p>

<p>The combined2 error model can be described by the following equation:
</p>
<p style="text-align: center;"><code class="reqn">y = f + \sqrt{a^2 + b^2\times f^{2\times c}} \times \varepsilon</code>
</p>

<p>Where:
</p>
<p>- y represents the observed value
</p>
<p>- f represents the predicted value
</p>
<p>- a  is the additive standard deviation
</p>
<p>- b is the proportional/power standard deviation
</p>
<p>- c is the power exponent (in the proportional case c=1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calcTables</code></td>
<td>
<p>This boolean is to determine if the foceiFit
will calculate tables. By default this is <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compress</code></td>
<td>
<p>Should the object have compressed items</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjObf</code></td>
<td>
<p>is a boolean to indicate if the objective function
should be adjusted to be closer to NONMEM's default objective
function.  By default this is <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>Confidence level for some tables.  By default this is
0.95 or 95% confidence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigdig</code></td>
<td>
<p>Optimization significant digits. This controls:
</p>

<ul>
<li>
<p> The tolerance of the inner and outer optimization is <code>10^-sigdig</code>
</p>
</li>
<li>
<p> The tolerance of the ODE solvers is
<code>0.5*10^(-sigdig-2)</code>; For the sensitivity equations and
steady-state solutions the default is <code>0.5*10^(-sigdig-1.5)</code>
(sensitivity changes only applicable for liblsoda)
</p>
</li>
<li>
<p> The tolerance of the boundary check is <code>5 * 10 ^ (-sigdig + 1)</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigdigTable</code></td>
<td>
<p>Significant digits in the final output table.
If not specified, then it matches the significant digits in the
'sigdig' optimization algorithm.  If 'sigdig' is NULL, use 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muRefCovAlg</code></td>
<td>
<p>This controls if algebraic expressions that can
be mu-referenced are treated as mu-referenced covariates by:
</p>
<p>1. Creating a internal data-variable 'nlmixrMuDerCov#' for each
algebraic mu-referenced expression
</p>
<p>2. Change the algebraic expression to 'nlmixrMuDerCov# * mu_cov_theta'
</p>
<p>3. Use the internal mu-referenced covariate for saem
</p>
<p>4. After optimization is completed, replace 'model()' with old
'model()' expression
</p>
<p>5. Remove 'nlmixrMuDerCov#' from nlmix2 output
</p>
<p>In general, these covariates should be more accurate since it
changes the system to a linear compartment model.  Therefore, by default this is 'TRUE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further, named control arguments to be passed to
<code>nlminb</code> (apart from <code>trace</code> and <code>iter.max</code>
mentioned above), where used (<code>eval.max</code> and those from
<code>abs.tol</code> down).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a nlmixr-nlme list
</p>


<h3>See Also</h3>

<p>Other Estimation control: 
<code>foceiControl()</code>,
<code>saemControl()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">nlmeControl()
nlmixr2NlmeControl()
</code></pre>


</div>