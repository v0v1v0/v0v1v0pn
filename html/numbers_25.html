<div class="container">

<table style="width: 100%;"><tr>
<td>Hermite normal form</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Hermite Normal Form
</h2>

<h3>Description</h3>

<p>Hermite normal form over integers (in column-reduced form).
</p>


<h3>Usage</h3>

<pre><code class="language-R">hermiteNF(A)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>integer matrix.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>An <code>mxn</code>-matrix of rank <code>r</code> with integer entries is said to be
in Hermite normal form if:
</p>
<p>(i) the first r columns are nonzero, the other columns are all zero;<br>
(ii) The first r diagonal elements are nonzero and d[i-1] divides d[i]
for i = 2,...,r .<br>
(iii) All entries to the left of nonzero diagonal elements are non-negative<br>
and strictly less than the corresponding diagonal entry.
</p>
<p>The lower-triangular Hermite normal form of A is obtained by the following 
three types of column operations:
</p>
<p>(i) exchange two columns<br>
(ii) multiply a column by -1<br>
(iii) Add an integral multiple of a column to another column
</p>
<p>U is the unitary matrix such that AU = H, generated by these operations.
</p>


<h3>Value</h3>

<p>List with two matrices, the Hermite normal form <code>H</code> and the unitary
matrix <code>U</code>.
</p>


<h3>Note</h3>

<p>Another normal form often used in this context is the Smith normal form.
</p>


<h3>References</h3>

<p>Cohen, H. (1993). A Course in Computational Algebraic Number Theory.
Graduate Texts in Mathematics, Vol. 138, Springer-Verlag, Berlin, New York.
</p>


<h3>See Also</h3>

<p><code>chinese</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">n &lt;- 4; m &lt;- 5
A = matrix(c(
 9,  6,  0, -8,  0,
-5, -8,  0,  0,  0,
 0,  0,  0,  4,  0,
 0,  0,  0, -5,  0), n, m, byrow = TRUE)
 
Hnf &lt;- hermiteNF(A); Hnf
# $H =  1    0    0    0    0
#       1    2    0    0    0
#      28   36   84    0    0
#     -35  -45 -105    0    0
# $U = 11   14   32    0    0
#      -7   -9  -20    0    0
#       0    0    0    1    0
#       7    9   21    0    0
#       0    0    0    0    1

r &lt;- 3                  # r = rank(H)
H &lt;- Hnf$H; U &lt;- Hnf$U
all(H == A %*% U)       #=&gt; TRUE

##  Example: Compute integer solution of A x = b
#   H = A * U, thus H * U^-1 * x = b, or H * y = b
b &lt;- as.matrix(c(-11, -21, 16, -20))

y &lt;- numeric(m)
y[1] &lt;- b[1] / H[1, 1]
for (i in 2:r)
    y[i] &lt;- (b[i] - sum(H[i, 1:(i-1)] * y[1:(i-1)])) / H[i, i]
# special solution:
xs &lt;- U %*% y         #  1 2 0 4 0

# and the general solution is xs + U * c(0, 0, 0, a, b), or
# in other words the basis are the m-r vectors c(0,...,0, 1, ...).
# If the special solution is not integer, there are no integer solutions.
</code></pre>


</div>