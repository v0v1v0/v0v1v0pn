<div class="container">

<table style="width: 100%;"><tr>
<td>modinv, modsqrt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Modular Inverse and Square Root</h2>

<h3>Description</h3>

<p>Computes the modular inverse of <code>n</code> modulo <code>m</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">modinv(n, m)

modsqrt(a, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n, m</code></td>
<td>
<p>integer scalars.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a, p</code></td>
<td>
<p>integer modulo p, p a prime.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The modular inverse of <code>n</code> modulo <code>m</code> is the unique natural
number <code>0 &lt; n0 &lt; m</code> such that <code>n * n0 = 1 mod m</code>. It is a
simple application of the extended GCD algorithm.
</p>
<p>The modular square root of <code>a</code> modulo a prime <code>p</code> is a number
<code>x</code> such that <code>x^2 = a mod p</code>. If <code>x</code> is a solution, then
<code>p-x</code> is also a solution module <code>p</code>. The function will always
return the smaller value.
</p>
<p><code>modsqrt</code> implements the Tonelli-Shanks algorithm which also works
for square roots modulo prime powers. The general case is NP-hard.
</p>


<h3>Value</h3>

<p>A natural number smaller <code>m</code>, if <code>n</code> and <code>m</code> are coprime,
else <code>NA</code>. <code>modsqrt</code> will return 0 if there is no solution.
</p>


<h3>See Also</h3>

<p><code>extGCD</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">modinv(5, 1001)  #=&gt; 801, as 5*801 = 4005 = 1 mod 1001

Modinv &lt;- Vectorize(modinv, "n")
((1:10)*Modinv(1:10, 11)) %% 11     #=&gt; 1 1 1 1 1 1 1 1 1 1

modsqrt( 8, 23)  # 10 because 10^2 = 100 = 8 mod 23
modsqrt(10, 17)  #  0 because 10 is not a quadratic residue mod 17
</code></pre>


</div>