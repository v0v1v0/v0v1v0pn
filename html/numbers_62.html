<div class="container">

<table style="width: 100%;"><tr>
<td>primroot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Primitive Root
</h2>

<h3>Description</h3>

<p>Find the smallest primitive root modulo m, or find all primitive roots.
</p>


<h3>Usage</h3>

<pre><code class="language-R">primroot(m, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>A prime integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all</code></td>
<td>
<p>boolean; shall all primitive roots module p be found.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For every prime number <code class="reqn">m</code> there exists a natural number <code class="reqn">n</code> that
generates the field <code class="reqn">F_m</code>, i.e. <code class="reqn">n, n^2, ..., n^{m-1} mod (m)</code> are
all different.
</p>
<p>The computation here is all brute force. As most primitive roots are
relatively small, so it is still reasonable fast.
</p>
<p>One trick is to factorize <code class="reqn">m-1</code> and test only for those prime factors.
In R this is not more efficient as factorization also takes some time.
</p>


<h3>Value</h3>

<p>A natural number if <code>m</code> is prime, else <code>NA</code>.
</p>


<h3>Note</h3>

<p>This function is <em>not</em> vectorized.
</p>


<h3>References</h3>

<p>Arndt, J. (2010). Matters Computational: Ideas, Algorithms, Source Code.
Springer-Verlag, Berlin Heidelberg Dordrecht.
</p>


<h3>See Also</h3>

<p><code>modpower</code>, <code>modorder</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">P &lt;- Primes(100)
R &lt;- c()
for (p in P) {
    R &lt;- c(R, primroot(p))
}
cbind(P, R)  # 7 is the biggest prime root here (for p=71)
</code></pre>


</div>